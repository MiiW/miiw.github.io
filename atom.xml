<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Study4Fun</title>
  
  <subtitle>学而时习之</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://study4.fun/"/>
  <updated>2022-05-21T07:33:16.600Z</updated>
  <id>https://study4.fun/</id>
  
  <author>
    <name>Mii Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes容器监控原理和源码解析（一）——API和数据来源</title>
    <link href="https://study4.fun/2022-05-13-kubernetes-pod-monitoring-1/"/>
    <id>https://study4.fun/2022-05-13-kubernetes-pod-monitoring-1/</id>
    <published>2022-05-13T14:54:00.000Z</published>
    <updated>2022-05-21T07:33:16.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列主要基于 v1.24.0 版本的 Kubelet 部分源代码，进行 Kubernetes 中容器监控的底层原理介绍与代码分析。</p><h2 id="Kubelet-中的监控-API"><a href="#Kubelet-中的监控-API" class="headerlink" title="Kubelet 中的监控 API"></a>Kubelet 中的监控 API</h2><p>在 Kubelet Server 提供的监控 API 中，大致可以分为两类：stats（统计数据）和 metrics（指标数据）。从命名和实际作用来看，前者提供了粗粒度的基础监控能力，目前用于各种内置组件；而后者用于持久化地进行细粒度的容器监控，主要提供给 Prometheus 等。</p><h3 id="统计类-API"><a href="#统计类-API" class="headerlink" title="统计类 API"></a>统计类 API</h3><p>在 v1.24.0 版本中，目前统计类接口仅包含/stats/summary，该接口提供了节点和 Pod 的统计信息。节点部分包括 CPU、内存、网络、文件系统、容器运行时、Rlimit 的统计。Pod 部分主要提供 Pod 相关的基础统计与卷、临时存储、进程统计外，主要还包括了各个容器的统计信息。容器部分值得关注的是，该接口中提供了用户自定义指标。方法实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">handleSummary</span><span class="params">(request *restful.Request, response *restful.Response)</span></span> &#123;</span><br><span class="line">onlyCPUAndMemory := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> onlyCluAndMemoryParam, found := request.Request.Form[<span class="string">"only_cpu_and_memory"</span>]; found &amp;&amp;</span><br><span class="line"><span class="built_in">len</span>(onlyCluAndMemoryParam) == <span class="number">1</span> &amp;&amp; onlyCluAndMemoryParam[<span class="number">0</span>] == <span class="string">"true"</span> &#123;</span><br><span class="line">onlyCPUAndMemory = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> summary *statsapi.Summary</span><br><span class="line"><span class="keyword">if</span> onlyCPUAndMemory &#123;</span><br><span class="line">summary, err = h.summaryProvider.GetCPUAndMemoryStats()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">forceStatsUpdate := <span class="literal">false</span></span><br><span class="line">summary, err = h.summaryProvider.Get(forceStatsUpdate)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 SummaryProvider 的实现可以发现，该实际上就是对 stats.Provider 的封装。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SummaryProvider <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(updateStats <span class="keyword">bool</span>) (*statsapi.Summary, error)</span><br><span class="line">GetCPUAndMemoryStats() (*statsapi.Summary, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> summaryProviderImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">kubeletCreationTime metav1.Time</span><br><span class="line">systemBootTime metav1.Time</span><br><span class="line"></span><br><span class="line">provider Provider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 handler 的处理逻辑中，它提供了一个只返回 CPU 和 Memory 信息的选项 onlyCPUAndMemory，如果只关心 cpu 和内存信息，通过此选项可以去除多余的统计信息，metrics-server(_&lt; 0.6.0 版本_)中就默认设置了该值。该部分需要注意的是，如果获取的是完整信息，那么监控信息是从缓存中获取的，这里特指 CPU 中的 NanoCoreUsage 不会更新，只有调用 onlyCPUAndMemory 才会将该值更新。如果基于接口做定制开发需要将 forceStatsUpdate 修改为 true 以保证 NanoCoreUsage 的准确性。<br>此外，在最新版本的 0.6.x 版本的 metrics-server 中已经不再依赖该接口，而是采用了 Kubelet 中的<a href="https://github.com/kubernetes-sigs/metrics-server/blob/6e196e2d01bdade760e9bc78c2e0abc473fdd819/pkg/scraper/client/resource/client.go#L91" target="_blank" rel="noopener">/metrics/resource 接口</a>进行资源的监控，在老版本集群中部署 metrics-server 时需要注意不兼容问题。</p><h3 id="指标类-API"><a href="#指标类-API" class="headerlink" title="指标类 API"></a>指标类 API</h3><p>Kubelet Server 提供的指标类 API 目前包括以下四个：</p><ul><li>/metrics：提供 kubelet 自身相关的一些监控，包括：apiserver 请求、go gc/内存/线程相关、kubelet 子模块关键信息、client-go 等指标</li><li>/metrics/cadvisor：提供 Pod/容器监控信息</li><li>/metrics/probes：提供对容器 Liveness/Readiness/Startup 探针的指标数据</li><li>/metrics/resource：提供 Pod/容器的 CPU 用量、wss 内存、启动时间基础指标数据</li></ul><p>上述四个接口返回的指标信息默认都是 Promtheus 格式。一般来说，指标想要转化为 Promtheus 格式需要实现 Prometheus client 的 Registerer 和 Gatherer 接口，而在 K8s 中对应的封装实现就是 KubeRegistry。这里我们先跳过 Prometheus client 的实现原理和其他非容器指标相关的实现，而是来看看容器指标数据是如何获取到并转化返回的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">r := compbasemetrics.NewKubeRegistry()</span><br><span class="line"></span><br><span class="line">includedMetrics := cadvisormetrics.MetricSet&#123;</span><br><span class="line">    <span class="comment">// 指标白名单设置</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cadvisorOpts := cadvisorv2.RequestOptions&#123;</span><br><span class="line">    IdType:    cadvisorv2.TypeName,</span><br><span class="line">    <span class="comment">// 每次仅返回一条数据</span></span><br><span class="line">    Count:     <span class="number">1</span>,</span><br><span class="line">    Recursive: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.RawMustRegister(metrics.NewPrometheusCollector(prometheusHostAdapter&#123;s.host&#125;, containerPrometheusLabelsFunc(s.host), includedMetrics, clock.RealClock&#123;&#125;, cadvisorOpts))</span><br><span class="line">r.RawMustRegister(metrics.NewPrometheusMachineCollector(prometheusHostAdapter&#123;s.host&#125;, includedMetrics))</span><br><span class="line"></span><br><span class="line">s.restfulCont.Handle(cadvisorMetricsPath,</span><br><span class="line">                     compbasemetrics.HandlerFor(r, compbasemetrics.HandlerOpts&#123;ErrorHandling: compbasemetrics.ContinueOnError&#125;),</span><br><span class="line">                    )</span><br></pre></td></tr></table></figure><p>在 Prometheus Client 的注册逻辑里，返回数据需要实现指标收集器（Collector）部分。这里可以看到，Kubelet 提供了两种数据收集器，一部分是 Pod/容器的指标收集器，另一部分是节点指标收集器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPrometheusMachineCollector</span><span class="params">(i infoProvider, includedMetrics container.MetricSet)</span> *<span class="title">PrometheusMachineCollector</span></span> &#123;</span><br><span class="line">c := &amp;PrometheusMachineCollector&#123;</span><br><span class="line"></span><br><span class="line">infoProvider: i,</span><br><span class="line">errors: prometheus.NewGauge(prometheus.GaugeOpts&#123;</span><br><span class="line">Namespace: <span class="string">"machine"</span>,</span><br><span class="line">Name:      <span class="string">"scrape_error"</span>,</span><br><span class="line">Help:      <span class="string">"1 if there was an error while getting machine metrics, 0 otherwise."</span>,</span><br><span class="line">&#125;),</span><br><span class="line">machineMetrics: []machineMetric&#123;</span><br><span class="line">&#123;</span><br><span class="line">name:      <span class="string">"machine_cpu_physical_cores"</span>,</span><br><span class="line">help:      <span class="string">"Number of physical CPU cores."</span>,</span><br><span class="line">valueType: prometheus.GaugeValue,</span><br><span class="line">getValues: <span class="function"><span class="keyword">func</span><span class="params">(machineInfo *info.MachineInfo)</span> <span class="title">metricValues</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> metricValues&#123;&#123;value: <span class="keyword">float64</span>(machineInfo.NumPhysicalCores), timestamp: machineInfo.Timestamp&#125;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其他指标的类似实现</span></span><br><span class="line">            ...</span><br><span class="line">&#125;...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到收集器实际上主要是通过 getValues 方法把 infoProvider 提供的数据结构从原始结构转成 Prometheus 中的指标，同时每个指标需要定义其名称、类型以及描述。节点和 Pod/容器对应的原始数据结构都定义在 cAdvisor 的 API Spec 中，即 MachineInfo 和 ContainerStats。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> infoProvider <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// GetRequestedContainersInfo gets info for all requested containers based on the request options.</span></span><br><span class="line">GetRequestedContainersInfo(containerName <span class="keyword">string</span>, options v2.RequestOptions) (<span class="keyword">map</span>[<span class="keyword">string</span>]*info.ContainerInfo, error)</span><br><span class="line"><span class="comment">// GetVersionInfo provides information about the version.</span></span><br><span class="line">GetVersionInfo() (*info.VersionInfo, error)</span><br><span class="line"><span class="comment">// GetMachineInfo provides information about the machine.</span></span><br><span class="line">GetMachineInfo() (*info.MachineInfo, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而从上面 KubeRegistry 的注册逻辑中可以看到，infoProvider 的实现又需要通过 prometheusHostAdapter 进行一次转换，其转换前的实现接口为 HostInterface。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> prometheusHostAdapter <span class="keyword">struct</span> &#123;</span><br><span class="line">host HostInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a prometheusHostAdapter)</span> <span class="title">GetRequestedContainersInfo</span><span class="params">(containerName <span class="keyword">string</span>, options cadvisorv2.RequestOptions)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]*cadvisorapi.ContainerInfo, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.host.GetRequestedContainersInfo(containerName, options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a prometheusHostAdapter)</span> <span class="title">GetVersionInfo</span><span class="params">()</span> <span class="params">(*cadvisorapi.VersionInfo, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.host.GetVersionInfo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a prometheusHostAdapter)</span> <span class="title">GetMachineInfo</span><span class="params">()</span> <span class="params">(*cadvisorapi.MachineInfo, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.host.GetCachedMachineInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 HostInterface 的定义中，查看监控相关的部分接口，prometheusHostAdapter 需要的 VersionInfo 和 MachineInfo 是由 Kubelet 实现的，而 GetRequestedContainersInfo 即容器相关监控信息的接口则由前面提到的 stats.Provider 中实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HostInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">stats.Provider</span><br><span class="line">GetVersionInfo() (*cadvisorapi.VersionInfo, error)</span><br><span class="line">GetCachedMachineInfo() (*cadvisorapi.MachineInfo, error)</span><br><span class="line">GetRunningPods() ([]*v1.Pod, error)</span><br><span class="line">GetHostname() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略监控无关接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监控数据提供方-Stats-Provider"><a href="#监控数据提供方-Stats-Provider" class="headerlink" title="监控数据提供方 Stats Provider"></a>监控数据提供方 Stats Provider</h2><h3 id="Provider-定义"><a href="#Provider-定义" class="headerlink" title="Provider 定义"></a>Provider 定义</h3><p>基于上一节分析，可以了解到 Kubelet Server 中返回的监控信息，无论是统计类信息还是指标类信息，容器相关的部分都是通过 stats.Provider 获取的。那么我们看看 stats.Provider 部分是如何定义的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Provider <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListPodStats 返回Pod管理的容器统计信息</span></span><br><span class="line">ListPodStats() ([]statsapi.PodStats, error)</span><br><span class="line">    <span class="comment">// ListPodCPUAndMemoryStats 返回Pod管理的容器统计信息（CPU/内存部分）</span></span><br><span class="line">ListPodCPUAndMemoryStats() ([]statsapi.PodStats, error)</span><br><span class="line"><span class="comment">// ListPodStatsAndUpdateCPUNanoCoreUsage 返回Pod管理的容器统计信息，这个方法会强制更新cpu的NanoCoreUsage信息，主要用于部分未内部集成cAdvisor的CRI Runtime实现。详见：https://github.com/kubernetes/kubernetes/issues/72788</span></span><br><span class="line">ListPodStatsAndUpdateCPUNanoCoreUsage() ([]statsapi.PodStats, error)</span><br><span class="line"><span class="comment">// ImageFsStats 返回镜像文件系统的统计信息</span></span><br><span class="line">ImageFsStats() (*statsapi.FsStats, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetCgroupStats 通过指定的cgroup名称返回统计信息及网络用量</span></span><br><span class="line">GetCgroupStats(cgroupName <span class="keyword">string</span>, updateStats <span class="keyword">bool</span>) (*statsapi.ContainerStats, *statsapi.NetworkStats, error)</span><br><span class="line"><span class="comment">// GetCgroupCPUAndMemoryStats 通过指定的cgroupName返回CPU和内存统计信息</span></span><br><span class="line">GetCgroupCPUAndMemoryStats(cgroupName <span class="keyword">string</span>, updateStats <span class="keyword">bool</span>) (*statsapi.ContainerStats, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RootFsStats 返回节点根分区的统计信息</span></span><br><span class="line">RootFsStats() (*statsapi.FsStats, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetContainerInfo 通过Pod Uid返回该Pod管理的容器的指标信息</span></span><br><span class="line">GetContainerInfo(podFullName <span class="keyword">string</span>, uid types.UID, containerName <span class="keyword">string</span>, req *cadvisorapi.ContainerInfoRequest) (*cadvisorapi.ContainerInfo, error)</span><br><span class="line"><span class="comment">// GetRawContainerInfo 通过容器名返回容器的指标信息，如果开启了subcontainers选项，则该方法会返回所有子容器的指标信息</span></span><br><span class="line">GetRawContainerInfo(containerName <span class="keyword">string</span>, req *cadvisorapi.ContainerInfoRequest, subcontainers <span class="keyword">bool</span>) (<span class="keyword">map</span>[<span class="keyword">string</span>]*cadvisorapi.ContainerInfo, error)</span><br><span class="line"><span class="comment">// GetRequestedContainersInfo 通过容器名返回容器的指标信息，同事提供了一些cAdvisor特定的可选参数</span></span><br><span class="line">GetRequestedContainersInfo(containerName <span class="keyword">string</span>, options cadvisorv2.RequestOptions) (<span class="keyword">map</span>[<span class="keyword">string</span>]*cadvisorapi.ContainerInfo, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPodByName 通过Pod的命名空间和名称返回具体的Pod信息</span></span><br><span class="line">GetPodByName(namespace, name <span class="keyword">string</span>) (*v1.Pod, <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">// GetNode 返回节点规格信息</span></span><br><span class="line">GetNode() (*v1.Node, error)</span><br><span class="line"><span class="comment">// GetNodeConfig 返回节点配置信息</span></span><br><span class="line">GetNodeConfig() cm.NodeConfig</span><br><span class="line"><span class="comment">// ListVolumesForPod 通过Pod Uid返回对应Pod使用的卷统计信息</span></span><br><span class="line">ListVolumesForPod(podUID types.UID) (<span class="keyword">map</span>[<span class="keyword">string</span>]volume.Volume, <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">// ListBlockVolumesForPod 通过Pod Uid返回对应Pod使用的块设备卷统计信息</span></span><br><span class="line">ListBlockVolumesForPod(podUID types.UID) (<span class="keyword">map</span>[<span class="keyword">string</span>]volume.BlockVolume, <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">// GetPods 返回节点上运行的所有Pod的信息</span></span><br><span class="line">GetPods() []*v1.Pod</span><br><span class="line"></span><br><span class="line"><span class="comment">// RlimitStats 返回系统的rlimit统计</span></span><br><span class="line">RlimitStats() (*statsapi.RlimitStats, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPodCgroupRoot 返回管理所有Pod的根Cgroup节点路径</span></span><br><span class="line">GetPodCgroupRoot() <span class="keyword">string</span></span><br><span class="line"><span class="comment">// GetPodByCgroupfs 通过cgroup路径名查找并返回Pod信息</span></span><br><span class="line">GetPodByCgroupfs(cgroupfs <span class="keyword">string</span>) (*v1.Pod, <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面 Provider 的接口划分，我们大致了解了 Kubelet 在监控方面提供的能力，主要包括容器、Pod、节点、文件系统的统计信息或指标信息等。其中不少接口都用到了 cgroup。<br>cgroup（control group）是 Linux 内核中用于限制、记录和隔离一组进程的资源使用（CPU、内存、磁盘 I/O、网络等）的模块，它与 namespace 一起作为基石构成了容器基础技术的实现。绝大部分场景下，大家对他比较熟悉的点在于其发挥的资源划分和限制能力，例如 K8S 中 Pod 与 Container 的 CPU/内存资源 Limit。除了资源限制能力外，实际上 cgroup 每个子系统还具有对应的统计能力。以 CPU 子系统为例，它可以统计 CPU 在用户空间和内核空间的运行时长分配、设置 Limit 后的 CPU 限流次数和限流总时长等：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/379285/1652198624416-d1d8746a-f7fa-4c24-997b-da9eb5f14cd7.png#clientId=u9c32ff6b-66ca-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=176&id=ufea51559&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=2504&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=62580&status=done&style=none&taskId=ua1faf7f4-c21a-4728-82a0-ab77bf6daf6&title=&width=1252" alt="image.png"><br>Cgroup 是以树形结构来划分和组织系统内的各个进程的，Kubelet 在运行时会创建一个 kubepods 的叶节点。而根据 Pod 的 QoS 等级划分，不同 Pod 被放在不同的 QoS 叶节点下。对应的，容器本身作为 Pod 管理的最小单元，其被划分在 Pod 的叶节点以下（_需开启 containerd 中 runc 的 SystemdCgroup 选项，否则 container 由 containerd cgroup 单独管理_）。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/379285/1652200676776-10e3ffcd-a3be-4ec0-b219-00d074eb4371.png#clientId=u8bb67b8d-f4bf-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=153&id=uf64befea&margin=%5Bobject%20Object%5D&name=image.png&originHeight=306&originWidth=1648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=68877&status=done&style=none&taskId=ue7983b8c-2cc5-4cdc-af99-253a4f53056&title=&width=824" alt="image.png"><br>大致了解了 Cgroup 之后，细心的你就能想明白在 Provider 中不太容易理的 GetRawContainerInfo 和 GetRequestedContainersInfo 接口的用法，即参数中的 Container 指的不仅是被 Pod 管理的 Container，其实指的也是 Cgroup 的叶节点。它可以是 Container/Pod/QoS/Kubepods，甚至是节点本身（即”/“）。这也能解释为什么会有 subcontainers 这个参数，毕竟 Container 作为最小运行单元肯定是不存在子容器这个说法的。subcontainers 可以直接理解为是否包含子节点的信息，GetRawContainerInfo 接口实际上是提供了当前节点与子节点的统计信息。</p><h3 id="Provider-初始化"><a href="#Provider-初始化" class="headerlink" title="Provider 初始化"></a>Provider 初始化</h3><p>provider 初始化包含在 Kubelet 的初始化流程中，通过 useLegacyCadvisorStats 开关，Kubelet 会进行会在 CadvisorStatsProvider 和 CRIStatsProvider 中选择一种作为实际实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMainKubelet</span><span class="params">(kubeCfg *kubeletconfiginternal.KubeletConfiguration, kubeDeps *Dependencies, ... )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他初始化流程</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">hostStatsProvider := stats.NewHostStatsProvider(kubecontainer.RealOS&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(podUID types.UID)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> getEtcHostsPath(klet.getPodDir(podUID))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> kubeDeps.useLegacyCadvisorStats &#123;</span><br><span class="line">klet.StatsProvider = stats.NewCadvisorStatsProvider(</span><br><span class="line">klet.cadvisor,</span><br><span class="line">klet.resourceAnalyzer,</span><br><span class="line">klet.podManager,</span><br><span class="line">klet.runtimeCache,</span><br><span class="line">klet.containerRuntime,</span><br><span class="line">klet.statusManager,</span><br><span class="line">hostStatsProvider)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klet.StatsProvider = stats.NewCRIStatsProvider(</span><br><span class="line">klet.cadvisor,</span><br><span class="line">klet.resourceAnalyzer,</span><br><span class="line">klet.podManager,</span><br><span class="line">klet.runtimeCache,</span><br><span class="line">kubeDeps.RemoteRuntimeService,</span><br><span class="line">kubeDeps.RemoteImageService,</span><br><span class="line">hostStatsProvider,</span><br><span class="line">utilfeature.DefaultFeatureGate.Enabled(features.DisableAcceleratorUsageMetrics)utilfeature.DefaultFeatureGate.Enabled(features.PodAndContainerStatsFromCRI))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两者的初始化方法可以分析得出其主要的数据来源都是 cadvisor 和 resourceAnalyzer，其他参数是主要作为一些辅助选项。resourceAnalyzer 主要提供了节点资源消耗的统计，除了文件系统相关的统计，其主要实现还是我们之前提到的 SummaryProvider。<br>那么基本可以得出一个结论，无论是哪种实现，容器相关的监控都主要来自于 cAdvisor。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章中，我们主要了解了 Kubelet Server 在对外提供的监控 API 中统计类和指标类的划分，并了解到容器监控的部分主要由 Stats Provider 定义。同时，我们也知道了目前 Kubelet 中对于 Stats Provider 的实现主要有两种——CadvisorStatsProvider 和 CRIStatsProvider。接下来的一篇文章，我们会对这两种实现进行深入的对比分析，并搞清楚两种 Provider 的实现是如何使用 cAdvisor 接口的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本系列主要基于 v1.24.0 版本的 Kubelet 部分源代码，进行 Kubernetes 中容器监控的底层原理介绍与代码分析。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://study4.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Kubernetes" scheme="https://study4.fun/tags/Kubernetes/"/>
    
      <category term="Pod" scheme="https://study4.fun/tags/Pod/"/>
    
      <category term="容器" scheme="https://study4.fun/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="监控" scheme="https://study4.fun/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>《KVM实战》读书笔记</title>
    <link href="https://study4.fun/2021-06-25-kvm-in-action-notes/"/>
    <id>https://study4.fun/2021-06-25-kvm-in-action-notes/</id>
    <published>2021-06-25T14:39:00.000Z</published>
    <updated>2022-05-21T07:33:16.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="技术手段"><a href="#技术手段" class="headerlink" title="技术手段"></a>技术手段</h4><table><thead><tr><th></th><th>软件虚拟化</th><th>硬件虚拟化</th></tr></thead><tbody><tr><td>含义</td><td>纯软件的环境模拟执行客户机的指令，如 QEMU</td><td>硬件本身提供能力让客户机指令独立执行，不需要 VMM 截获重定向，如 Intel VT</td></tr><tr><td>实现</td><td>二进制翻译（不同指令集的二进制代码转换）</td><td>1.（x86 实现）提供略微受限的硬件运行环境（non-root mode），无需翻译再执行 2.VMM 运行在 root mode，具备硬件的完整访问控制权限；仅在部分情况下，客户机指令需要被 VMM 截获处理再返回 non-root mode</td></tr><tr><td>优缺点</td><td>虚拟化性能差，软件复杂度高；支持各种平台（二进制翻译支持）</td><td>性能接近于原生系统，简化了 VMM 的设计结构</td></tr></tbody></table><h4 id="虚拟化程度"><a href="#虚拟化程度" class="headerlink" title="虚拟化程度"></a>虚拟化程度</h4><p>半虚拟化：</p><ul><li>客户机意识到自己运行在虚拟化环境内，需做相应的修改配合 VMM</li><li>性能提升，VMM 软件复杂度降低；不太依赖硬件虚拟化的支持，支持跨平台</li><li>virtio，宿主机/VMM 和客户机需要相应的安装驱动</li></ul><p>全虚拟化：</p><ul><li>客户机 OS 无改动，需要模拟完整的、和物理平台一模一样的平台提供给客户机</li><li>增加了 VMM 的复杂度，软件实现的全虚拟化性能差</li><li>硬件虚拟化辅助的全虚拟化性能反超半虚拟化</li></ul><h4 id="软件框架"><a href="#软件框架" class="headerlink" title="软件框架"></a>软件框架</h4><p><strong>判断标准</strong>：VMM 是直接位于硬件之上还是在一个宿主操作系统上<br>Type1：</p><ul><li>native/bare-metal hypervisor，直接控制硬件资源及客户机</li><li>Xen, VMware Esx</li></ul><p>Type2：</p><ul><li>运行在宿主机 OS 上，通常就是以进程的形式存在</li><li>KVM, VMWare Workstation</li></ul><h3 id="硬件虚拟化"><a href="#硬件虚拟化" class="headerlink" title="硬件虚拟化"></a>硬件虚拟化</h3><p>(TODO)</p><h4 id="CPU-虚拟化"><a href="#CPU-虚拟化" class="headerlink" title="CPU 虚拟化"></a>CPU 虚拟化</h4><h4 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h4><h4 id="I-O-虚拟化"><a href="#I-O-虚拟化" class="headerlink" title="I/O 虚拟化"></a>I/O 虚拟化</h4><h2 id="KVM-介绍"><a href="#KVM-介绍" class="headerlink" title="KVM 介绍"></a>KVM 介绍</h2><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><ul><li>采用<strong>硬件虚拟化</strong>的<strong>全虚拟化</strong>解决方案</li><li>基于内核，通过加载模块使内核本身成为 Hypervisor</li><li>Type2 Hypervisor</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ul><li>客户机物理内存就是宿主机内普通进程的虚拟内存，这意味着 linux 内存管理的机制全部可以应用到客户机内存管理上</li><li>早期实现：GVA-&gt;GPA-&gt;HVA-&gt;HPA；GVA-&gt;GPA：页表，GPA-&gt;HPA：影子页表</li><li>现在的实现：通过硬件识别的数据结构算出 GPA 到 HPA 的转换关系，如 EPT/NPT</li></ul><h4 id="存储和镜像"><a href="#存储和镜像" class="headerlink" title="存储和镜像"></a>存储和镜像</h4><ul><li>可使用 linux 支持的任意存储来存虚拟机镜像，支持按需分配、稀疏存储</li><li>原生磁盘格式为 qcow2，支持快照、压缩、加密</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>实时迁移，用户透明，支持状态存储及恢复</li><li>支持混合虚拟化（virtio，pci passthrough）</li><li>资源可伸缩，95%原生性能</li></ul><h3 id="功能框架"><a href="#功能框架" class="headerlink" title="功能框架"></a>功能框架</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/379285/1624633915921-7254d4c6-8a52-40d1-a555-454e3ae980e4.png#clientId=u54e1a765-b574-4&from=paste&height=1017&id=ud6368260&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2033&originWidth=1920&originalType=binary%E2%88%B6=2&size=353391&status=done&style=none&taskId=u816778ac-38b6-4b74-8778-85719e968a7&width=960" alt="image.png"></p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>一个 Guest VM 对应 Host 中的一个 qemu 进程，一个 Guest vCpu 对应进程中的一个 qemu 线程</li><li>IO 处理线程是单独的，在一个线程组内</li><li>客户机（进程）由内核调度，借用<strong>进程调度</strong>的手段实现不同客户机的<strong>权限限定</strong>和<strong>优先级</strong>等功能</li><li>QEMU 实现硬件设备模拟（透传除外），截获并对物理设备驱动进行操作</li></ul><h4 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h4><h5 id="KVM-内核模块"><a href="#KVM-内核模块" class="headerlink" title="KVM 内核模块"></a>KVM 内核模块</h5><ul><li>主要负责 CPU 和内存的虚拟化，所有 Guest 与唯一的内核模块进行交互</li><li>分为处理器架构无关(kvm)和有关(kvm_intel)的两个部分</li></ul><h5 id="QEMU-用户态工具"><a href="#QEMU-用户态工具" class="headerlink" title="QEMU 用户态工具"></a>QEMU 用户态工具</h5><ul><li>提供设备模拟的功能，ioctl syscall 与内核态 kvm 模块交互</li><li>qemu 本身具备完整的虚拟机实现（cpu/mem 虚拟化）</li><li>支持 virtio 协议的设备模拟，实现了 virtio 的虚拟化后端</li></ul><h4 id="其他相关组件"><a href="#其他相关组件" class="headerlink" title="其他相关组件"></a>其他相关组件</h4><ul><li>vhost-net：替代 virtio-net</li><li>open vswitch：多层虚拟交换机</li><li>dpdk<ul><li>网络应用中数据包的高性能处理，运行在用户空间，绕过内核协议栈对数据包的处理</li><li>提升小包等网络处理能力，可与 vhost-uset 结合使用</li></ul></li><li>spdk：高存储性能支持，驱动运行在用户态实现零拷贝、轮询替代传统的中断模式、无锁设计</li><li>管理工具<ul><li>libvirt：kvm 虚拟化管理的工具和应用程序接口，事实上的虚拟化接口标准</li><li>virsh：命令行工具</li><li>virt-manager：图形化管理软件</li><li>openstack：云管理平台</li></ul></li></ul><h3 id="KVM-操作"><a href="#KVM-操作" class="headerlink" title="KVM 操作"></a>KVM 操作</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bios中确认打开Intel VT/VT-d</span></span><br><span class="line"><span class="comment"># cpu标志确认虚拟化支持</span></span><br><span class="line">grep -E <span class="string">"svm|vmx"</span> /proc/cpuinfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># kvm模块加载</span></span><br><span class="line">modprobe kvm</span><br><span class="line">modprobe kvm_intel</span><br><span class="line">lsmod | grep kvm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查控制接口文件</span></span><br><span class="line">ls -l /dev/kvm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认安装的qemu版本比较老，编译安装最新版本的</span></span><br><span class="line"> git <span class="built_in">clone</span> git://git.qemu.org/qemu.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译配置所需</span></span><br><span class="line"> yum install -y python3 ninja-build gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行配置，只安装x86_64客户机支持</span></span><br><span class="line"> ./configure --target-list=x86_64-softmmu</span><br></pre></td></tr></table></figure><p>旧版本需要安装 qemu-kvm，新版本 qemu 增加 –enable-kvm 选项即可</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以raw格式创建一个大小20G的盘，默认按需分配</span></span><br><span class="line">qemu-img create -f raw rhel7.img 20G</span><br><span class="line"></span><br><span class="line"><span class="comment"># ls -lh | grep rhel7.img</span></span><br><span class="line">-rw-r--r--  1 root root  20G Jun 28 11:57 rhel7.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># du -sh rhel7.img，按需分配，实际占用为0</span></span><br><span class="line">0rhel7.img</span><br></pre></td></tr></table></figure><h2 id="libvirt"><a href="#libvirt" class="headerlink" title="libvirt"></a>libvirt</h2><h3 id="定位-1"><a href="#定位-1" class="headerlink" title="定位"></a>定位</h3><ul><li>对 KVM 虚拟机进行管理的<strong>工具</strong>和<strong>应用程序接口</strong></li><li>也提供了对虚拟化网络和存储的管理</li><li>主要作为连接底层 Hypervisor 和上层应用程序的一个中间适配层</li></ul><h3 id="交互框架"><a href="#交互框架" class="headerlink" title="交互框架"></a>交互框架</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/379285/1624977807324-7ab1a21e-419d-470b-921f-138c087ad366.png#clientId=ub242abda-aa54-4&from=paste&height=308&id=u9efea914&margin=%5Bobject%20Object%5D&name=image.png&originHeight=381&originWidth=588&originalType=binary%E2%88%B6=2&size=358803&status=done&style=none&taskId=u55155de4-5b96-4eb6-8d71-40d80f29c9b&width=475" alt="image.png"></p><ul><li>通过基于驱动程序的架构实现多种 Hypervisor 的支持</li><li>屏蔽底层 Hypervisor 的细节，为上层提供统一的稳定的 API</li></ul><h3 id="组成和功能"><a href="#组成和功能" class="headerlink" title="组成和功能"></a>组成和功能</h3><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>应用接口编程接口库，守护进程（libvirtd)，命令行管理工具(virsh)<br>libvirtd：可运行在 root 或普通用户权限下，root 用户权限支持所有管理操作，普通用户则受限</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li>域管理：域生命周期管理，多种设备的热插拔</li><li>远程节点管理：支持<strong>多种网络远程传输类型</strong>连接运行了 libvirtd 的物理节点</li><li>存储管理：管理不同类型的存储，支持远程管理</li><li>网络管理：管理物理和逻辑网络接口</li><li>提供稳定可靠高效的应用程序接口</li></ol><h3 id="XML-配置"><a href="#XML-配置" class="headerlink" title="XML 配置"></a>XML 配置</h3><h4 id="CPU-配置"><a href="#CPU-配置" class="headerlink" title="CPU 配置"></a>CPU 配置</h4><p>vcpu：cpu 个数</p><ul><li>vcpu.cpuset: 指定允许执行的物理 CPU</li></ul><p>features：CPU 或其他硬件特性的开关<br>cpu.mode:</p><ul><li>custom:个性化设置</li><li>host-model:根据物理 CPU 特性选择一个最接近的标准 CPU 型号</li><li>host-passthrough：暴露 CPU 物理特性给 Guest</li></ul><p>cputune：绑核、CPU 时间加权配置等等</p><h4 id="内存配置"><a href="#内存配置" class="headerlink" title="内存配置"></a>内存配置</h4><p>memory:可使用内存的最大值<br>currentMemory：启动时分配的内存<br>devices.memballoon:内存 balloning 调节</p><h4 id="Guest-OS-和-Boot-配置"><a href="#Guest-OS-和-Boot-配置" class="headerlink" title="Guest OS 和 Boot 配置"></a>Guest OS 和 Boot 配置</h4><p>os.tpye:GuestOS 类型，kvm 中为 hvm<br>os.boot：guest vm 启动设备配置</p><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p>interface.type: bridge，桥接网络；network，NAT 网络；user，用户模式网络；hostdev，设备直接分配给 Guest</p><h4 id="存储配置"><a href="#存储配置" class="headerlink" title="存储配置"></a>存储配置</h4><p>disk.type: file/block（块设备）/dir/network,磁盘来源类型<br>disk.device:floppy/disk（默认值）/cdrom/lun，Guest 内使用<br>disk.source:磁盘来源，和 type 配合使用<br>disk.driver:hypervisor 提供的磁盘驱动，name=qemu<br>disk.target:暴露给 Guest 的总线类型和设备名称<br>disk.address:Guest 内的 PCI 总线地址</p><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4><h5 id="域配置"><a href="#域配置" class="headerlink" title="域配置"></a>域配置</h5><p>domain.type：虚拟化类型,xen/kvm/qemu/lxc…<br>domain.id: guest 唯一 id<br>domain.name/uuid/…: 元数据</p><h5 id="QEMU-模拟器配置"><a href="#QEMU-模拟器配置" class="headerlink" title="QEMU 模拟器配置"></a>QEMU 模拟器配置</h5><p>device.emulator:使用的设备模型模拟器，绝对路径</p><h5 id="图形显示"><a href="#图形显示" class="headerlink" title="图形显示"></a>图形显示</h5><p>devices.graphics:连接 Guest 的图形显示方式，vnc/sdl/rdp…</p><h5 id="声卡-显卡"><a href="#声卡-显卡" class="headerlink" title="声卡/显卡"></a>声卡/显卡</h5><p>devices.sound:模拟声卡<br>devices.video:模拟显卡，vram 代表显存，heads 屏幕序号</p><h5 id="串口和控制台"><a href="#串口和控制台" class="headerlink" title="串口和控制台"></a>串口和控制台</h5><p>devices.serial:串口，target 指 Guest 内串口编号，source 指 Host 内的虚拟 pts 终端号<br>devices.console:控制台配置，type=serial，Guest 内类型</p><h5 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h5><p>devices.input：qemu 模拟的输入设备，mouse/keyboard/tablet</p><h5 id="PCI-控制器"><a href="#PCI-控制器" class="headerlink" title="PCI 控制器"></a>PCI 控制器</h5><p>domain.controller:类型有 usb/pci/virtio-serial</p><h3 id="libvirt-api"><a href="#libvirt-api" class="headerlink" title="libvirt api"></a>libvirt api</h3><p>Hypervisor 连接（virConnect）<br>域管理（virDomain）<br>节点管理（virNode）<br>网络管理（virNetowrk）<br>存储卷管理（virStorageVol）：域的镜像文件管理<br>存储池管理（virStoragePool）：本地、网络共享、iSCSI 文件系统以及 LVM 分区管理<br>事件管理（virEvent）：事件机制支持，注册后事件发生后可收到通知<br>数据流管理（virStream）：数据流传输</p><h3 id="libvirt-uri"><a href="#libvirt-uri" class="headerlink" title="libvirt uri"></a>libvirt uri</h3><h4 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h4><p><strong>格式</strong>：driver[+transport]:///[path][extral-param]<br><strong>示例</strong>：<br>qemu:///session<br>qemu+unix:///session<br>qemu:///system<br>qemu+unix:///system</p><h4 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h4><p><strong>格式</strong>：driver[+transport]://[uesr@][host][:port]/[path][extral-param]<br><strong>示例</strong>：<br>qemu+ssh://root@example.com/system<br>qemu+ssh://user@example.com/session<br>qemu://example.com/system(TLS 连接)<br>qemu+tcp//example.com/system(非加密 TCP)</p><h4 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h4><p>virsh: 相关操作命令[<img src="https://libvirt.org/manpages/virsh.html" alt="https://libvirt.org/manpages/virsh.html">]<br>virt manager:图形化管理[<img src="https://virt-manager.org/" alt="https://virt-manager.org/">]<br>virt viewer:图形化控制台[<img src="https://linux.die.net/man/1/virt-viewer" alt="https://linux.die.net/man/1/virt-viewer">]</p><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>新版本 qemu 编译安装的时候依赖 gcc 7.5+版本</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>设备模型<br>桥接网络和 NAT 网络的区别<br>用户模式网络：qemu 软件模拟的网络协议栈，宿主机中没有虚拟网络接口连接到网桥<br>istio-iptables</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/music-liang/p/12900457.html" target="_blank" rel="noopener">https://www.cnblogs.com/music-liang/p/12900457.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;虚拟化&quot;&gt;&lt;a href=&quot;#虚拟化&quot; class=&quot;headerlink&quot; title=&quot;虚拟化&quot;&gt;&lt;/a&gt;虚拟化&lt;/h2&gt;&lt;h3 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h3&gt;&lt;h
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://study4.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://study4.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="KVM" scheme="https://study4.fun/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>Kubelet Image GC原理分析</title>
    <link href="https://study4.fun/2021-04-25-analysis-of-kubelet-imagegc/"/>
    <id>https://study4.fun/2021-04-25-analysis-of-kubelet-imagegc/</id>
    <published>2021-04-25T07:48:00.000Z</published>
    <updated>2022-05-21T07:33:16.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Image-GC-是什么？"><a href="#Image-GC-是什么？" class="headerlink" title="Image GC 是什么？"></a>Image GC 是什么？</h2><p>Image GC 是 kubelet 的镜像清理功能，用于在磁盘空间不足的情况下清除不需要的镜像，释放磁盘空间，保证 Pod 能正常启动运行。</p><h2 id="Image-GC-如何使用？"><a href="#Image-GC-如何使用？" class="headerlink" title="Image GC 如何使用？"></a>Image GC 如何使用？</h2><p>Kubelet 默认开启，通过 kubele 启动配置中的 ImageGCPolicy 控制。ImageGCPolicy 有三个设置参数：</p><ul><li>ImageGCHighThresholdPercent：触发 gc 的阈值，超过该值将会执行 gc，设置为 100 时，gc 不启动。</li><li>ImageGCLowThresholdPercent：ImageGC 执行空间空间的目标值，gc 触发后，将会将磁盘占用率降至该值以下；</li><li>ImageMinimumGCAge：最短 GC 年龄（即距离首次被探测到的间隔），小于该阈值时不会被 gc。</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ImageGC-的初始化与启动"><a href="#ImageGC-的初始化与启动" class="headerlink" title="ImageGC 的初始化与启动"></a>ImageGC 的初始化与启动</h3><p>在 kubelet 启动时，ImageGC 的启动在 BirthCry 执行完成之后。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">StartGarbageCollection</span><span class="params">()</span></span> &#123;</span><br><span class="line">loggedContainerGCFailure := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// container gc流程，省略</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageGCHighThresholdPercent设置为100时，关闭image gc</span></span><br><span class="line"><span class="keyword">if</span> kl.kubeletConfiguration.ImageGCHighThresholdPercent == <span class="number">100</span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).Infof(<span class="string">"ImageGCHighThresholdPercent is set 100, Disable image GC"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prevImageGCFailed := <span class="literal">false</span></span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := kl.imageManager.GarbageCollect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> prevImageGCFailed &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Image garbage collection failed multiple times in a row: %v"</span>, err)</span><br><span class="line"><span class="comment">// Only create an event for repeated failures</span></span><br><span class="line">kl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.ImageGCFailed, err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"Image garbage collection failed once. Stats initialization may not have completed yet: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">prevImageGCFailed = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">var</span> vLevel klog.Level = <span class="number">4</span></span><br><span class="line"><span class="keyword">if</span> prevImageGCFailed &#123;</span><br><span class="line">vLevel = <span class="number">1</span></span><br><span class="line">prevImageGCFailed = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(vLevel).Infof(<span class="string">"Image garbage collection succeeded"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, ImageGCPeriod, wait.NeverStop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，ImageGC 由单独的协程执行，默认的执行间隔为五分钟。当 ImageGC 首次执行失败时会打印日志，而重复失败后，会记录一个 ImageGCFailed 的事件。这意味着可以通过配置日志或者告警了解 GC 是否正常运行。<br>接下来看看 ImageGCManager 的具体实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ImageGCManager <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Applies the garbage collection policy. Errors include being unable to free</span></span><br><span class="line"><span class="comment">// enough space as per the garbage collection policy.</span></span><br><span class="line">GarbageCollect() error</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start async garbage collection of images.</span></span><br><span class="line">Start()</span><br><span class="line"></span><br><span class="line">GetImageList() ([]container.Image, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete all unused images.</span></span><br><span class="line">DeleteUnusedImages() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImageGCManager</span><span class="params">(runtime container.Runtime, statsProvider StatsProvider, recorder record.EventRecorder, nodeRef *v1.ObjectReference, policy ImageGCPolicy, sandboxImage <span class="keyword">string</span>)</span> <span class="params">(ImageGCManager, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Validate policy.</span></span><br><span class="line"><span class="keyword">if</span> policy.HighThresholdPercent &lt; <span class="number">0</span> || policy.HighThresholdPercent &gt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid HighThresholdPercent %d, must be in range [0-100]"</span>, policy.HighThresholdPercent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> policy.LowThresholdPercent &lt; <span class="number">0</span> || policy.LowThresholdPercent &gt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid LowThresholdPercent %d, must be in range [0-100]"</span>, policy.LowThresholdPercent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> policy.LowThresholdPercent &gt; policy.HighThresholdPercent &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"LowThresholdPercent %d can not be higher than HighThresholdPercent %d"</span>, policy.LowThresholdPercent, policy.HighThresholdPercent)</span><br><span class="line">&#125;</span><br><span class="line">im := &amp;realImageGCManager&#123;</span><br><span class="line">runtime:       runtime,</span><br><span class="line">policy:        policy,</span><br><span class="line">imageRecords:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*imageRecord),</span><br><span class="line">statsProvider: statsProvider,</span><br><span class="line">recorder:      recorder,</span><br><span class="line">nodeRef:       nodeRef,</span><br><span class="line">initialized:   <span class="literal">false</span>,</span><br><span class="line">sandboxImage:  sandboxImage,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> im, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImageGCManager 的接口非常简单，只有四个方法：</p><ul><li>GarbageCollect：根据定义的 ImageGCPolicy 执行具体的清理动作；</li><li>Start：异步地收集镜像信息；</li><li>GetImageList：获取缓存中的镜像列表；</li><li>DeleteUnusedImages：删除未使用的镜像。</li></ul><p>ImageGCManager 在初始化时会校验 Policy 的参数合法性，然后传递运行时、监控、事件等参数。然后看看 Start 方法的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(im *realImageGCManager)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Initial detection make detected time "unknown" in the past.</span></span><br><span class="line"><span class="keyword">var</span> ts time.Time</span><br><span class="line"><span class="keyword">if</span> im.initialized &#123;</span><br><span class="line">ts = time.Now()</span><br><span class="line">&#125;</span><br><span class="line">_, err := im.detectImages(ts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Warningf(<span class="string">"[imageGCManager] Failed to monitor images: %v"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">im.initialized = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">5</span>*time.Minute, wait.NeverStop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start a goroutine periodically updates image cache.</span></span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">images, err := im.runtime.ListImages()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Warningf(<span class="string">"[imageGCManager] Failed to update image list: %v"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">im.imageCache.set(images)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">30</span>*time.Second, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImageGCManager 的 Start 方法会启动两个协程。在第一个协程内，每隔五分钟 Manager 会检查一次镜像。一旦完成一次，Manager 的状态就会被标记为已初始化。另一个协程每隔 30 秒会从容器运行时获取所有的镜像信息，更新到缓存的镜像列表中。</p><h3 id="镜像信息的检测和维护"><a href="#镜像信息的检测和维护" class="headerlink" title="镜像信息的检测和维护"></a>镜像信息的检测和维护</h3><p>那么，Manager 时如何检测镜像的呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(im *realImageGCManager)</span> <span class="title">detectImages</span><span class="params">(detectTime time.Time)</span> <span class="params">(sets.String, error)</span></span> &#123;</span><br><span class="line">imagesInUse := sets.NewString()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Always consider the container runtime pod sandbox image in use</span></span><br><span class="line">imageRef, err := im.runtime.GetImageRef(container.ImageSpec&#123;Image: im.sandboxImage&#125;)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; imageRef != <span class="string">""</span> &#123;</span><br><span class="line">imagesInUse.Insert(imageRef)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">images, err := im.runtime.ListImages()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> imagesInUse, err</span><br><span class="line">&#125;</span><br><span class="line">pods, err := im.runtime.GetPods(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> imagesInUse, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make a set of images in use by containers.</span></span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">for</span> _, container := <span class="keyword">range</span> pod.Containers &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">"Pod %s/%s, container %s uses image %s(%s)"</span>, pod.Namespace, pod.Name, container.Name, container.Image, container.ImageID)</span><br><span class="line">imagesInUse.Insert(container.ImageID)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add new images and record those being used.</span></span><br><span class="line">now := time.Now()</span><br><span class="line">currentImages := sets.NewString()</span><br><span class="line">im.imageRecordsLock.Lock()</span><br><span class="line"><span class="keyword">defer</span> im.imageRecordsLock.Unlock()</span><br><span class="line"><span class="keyword">for</span> _, image := <span class="keyword">range</span> images &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">"Adding image ID %s to currentImages"</span>, image.ID)</span><br><span class="line">currentImages.Insert(image.ID)</span><br><span class="line"></span><br><span class="line"><span class="comment">// New image, set it as detected now.</span></span><br><span class="line"><span class="keyword">if</span> _, ok := im.imageRecords[image.ID]; !ok &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">"Image ID %s is new"</span>, image.ID)</span><br><span class="line">im.imageRecords[image.ID] = &amp;imageRecord&#123;</span><br><span class="line">firstDetected: detectTime,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set last used time to now if the image is being used.</span></span><br><span class="line"><span class="keyword">if</span> isImageUsed(image.ID, imagesInUse) &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">"Setting Image ID %s lastUsed to %v"</span>, image.ID, now)</span><br><span class="line">im.imageRecords[image.ID].lastUsed = now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">"Image ID %s has size %d"</span>, image.ID, image.Size)</span><br><span class="line">im.imageRecords[image.ID].size = image.Size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove old images from our records.</span></span><br><span class="line"><span class="keyword">for</span> image := <span class="keyword">range</span> im.imageRecords &#123;</span><br><span class="line"><span class="keyword">if</span> !currentImages.Has(image) &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">"Image ID %s is no longer present; removing from imageRecords"</span>, image)</span><br><span class="line"><span class="built_in">delete</span>(im.imageRecords, image)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> imagesInUse, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测镜像的目的是找出正在使用的镜像，防止在 GC 执行的过程中被清理。同时，在此过程中，镜像的清理需要参考一些信息，这些信息也会在检测的过程中更新。<br>首先，Sandbox 镜像是一定会被判定为正在使用的镜像。接着会将所有 Pod 的所有<strong>正在运行中的容器使用</strong>的 image 加到正在使用的镜像列表中。注意，即使 Pod 有容器需要该镜像，但是该容器未处于 Running 状态，其对应的镜像也会被清理。<br>选出正在使用（即不会被清理）的镜像之后，会将容器运行时中获取到的镜像列表信息更新到 Manager 维护的镜像列表记录中。<br>查询所有新获取的镜像列表信息进行遍历，分为以下几步：</p><ul><li>如果是第一次被记录，那么更新该镜像的首次被探测时间为本轮探测的事件</li><li>如果被前面一步被判定为“正在使用的镜像”，那么它的最新使用事件会被刷新为当前时间</li><li>刷新获取到的镜像的大小</li></ul><p>最后，如果某个镜像已经不在容器运行时返回的镜像列表中，就会被移出 Manager 缓存的镜像探测记录。</p><h3 id="ImageGC-的具体执行"><a href="#ImageGC-的具体执行" class="headerlink" title="ImageGC 的具体执行"></a>ImageGC 的具体执行</h3><p>ImageGCManager 的核心方法就是 GarbageCollect 了，主要步骤如下：首先获取 Image 对应的 Filesystem 占用信息，根据启动的配置计算出用量百分比以及需要释放的空间大小，然后开始释放。如果实际释放的空间小于目标大小，会记录 FreeDiskSpaceFailed 的 Warnning 事件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(im *realImageGCManager)</span> <span class="title">GarbageCollect</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Get disk usage on disk holding images.</span></span><br><span class="line">fsStats, err := im.statsProvider.ImageFsStats()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> capacity, available <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">if</span> fsStats.CapacityBytes != <span class="literal">nil</span> &#123;</span><br><span class="line">capacity = <span class="keyword">int64</span>(*fsStats.CapacityBytes)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fsStats.AvailableBytes != <span class="literal">nil</span> &#123;</span><br><span class="line">available = <span class="keyword">int64</span>(*fsStats.AvailableBytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> available &gt; capacity &#123;</span><br><span class="line">klog.Warningf(<span class="string">"available %d is larger than capacity %d"</span>, available, capacity)</span><br><span class="line">available = capacity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check valid capacity.</span></span><br><span class="line"><span class="keyword">if</span> capacity == <span class="number">0</span> &#123;</span><br><span class="line">err := goerrors.New(<span class="string">"invalid capacity 0 on image filesystem"</span>)</span><br><span class="line">im.recorder.Eventf(im.nodeRef, v1.EventTypeWarning, events.InvalidDiskCapacity, err.Error())</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If over the max threshold, free enough to place us at the lower threshold.</span></span><br><span class="line">usagePercent := <span class="number">100</span> - <span class="keyword">int</span>(available*<span class="number">100</span>/capacity)</span><br><span class="line"><span class="keyword">if</span> usagePercent &gt;= im.policy.HighThresholdPercent &#123;</span><br><span class="line">amountToFree := capacity*<span class="keyword">int64</span>(<span class="number">100</span>-im.policy.LowThresholdPercent)/<span class="number">100</span> - available</span><br><span class="line">klog.Infof(<span class="string">"[imageGCManager]: Disk usage on image filesystem is at %d%% which is over the high threshold (%d%%). Trying to free %d bytes down to the low threshold (%d%%)."</span>, usagePercent, im.policy.HighThresholdPercent, amountToFree, im.policy.LowThresholdPercent)</span><br><span class="line">freed, err := im.freeSpace(amountToFree, time.Now())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> freed &lt; amountToFree &#123;</span><br><span class="line">err := fmt.Errorf(<span class="string">"failed to garbage collect required amount of images. Wanted to free %d bytes, but freed %d bytes"</span>, amountToFree, freed)</span><br><span class="line">im.recorder.Eventf(im.nodeRef, v1.EventTypeWarning, events.FreeDiskSpaceFailed, err.Error())</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算出需要释放空间后是删除的镜像是怎么决定的呢？在开始执行清理时，会执行我们上面介绍的镜像探测过程。在完成镜像探测后，我们的得到的 imagesInUse 包括了 Sanbox 镜像以及 Pod 内正在与运行中容器使用的镜像。接下来，要选出清理的目标镜像，存放清理目标的数据结构叫 evictionInfo，它存放了所有不在 imagesInUse 列表内的镜像记录。接着会将这些镜像记录按照 <strong>最后使用时间</strong> 和 <strong>首次探测时间</strong> 进行一次排序，即按照 LRU 规则将最后一次使用时间较早和探测事件较早的镜像排在前面。<br>排序完之后，会遍历所有这些镜像：如果是镜像最后一次使用事件没有删除触发时间早（即刚刚刷新了最后使用时间），则不会删除。同时，如果该镜像首次被探测到的时间差小于配置的最小 GC 间隔（即刚加入到缓存记录中），也不会删除。否则，就会依序删除这些镜像，删除完之后会从探测记录中删除该镜像同时累加 已经释放的空间值 spaceFreed。如果 spaceFreed 不小于<strong>目标释放的空间</strong>，则本轮的清理正常结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(im *realImageGCManager)</span> <span class="title">freeSpace</span><span class="params">(bytesToFree <span class="keyword">int64</span>, freeTime time.Time)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">imagesInUse, err := im.detectImages(freeTime)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">im.imageRecordsLock.Lock()</span><br><span class="line"><span class="keyword">defer</span> im.imageRecordsLock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all images in eviction order.</span></span><br><span class="line">images := <span class="built_in">make</span>([]evictionInfo, <span class="number">0</span>, <span class="built_in">len</span>(im.imageRecords))</span><br><span class="line"><span class="keyword">for</span> image, record := <span class="keyword">range</span> im.imageRecords &#123;</span><br><span class="line"><span class="keyword">if</span> isImageUsed(image, imagesInUse) &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">"Image ID %s is being used"</span>, image)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">images = <span class="built_in">append</span>(images, evictionInfo&#123;</span><br><span class="line">id:          image,</span><br><span class="line">imageRecord: *record,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">sort.Sort(byLastUsedAndDetected(images))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete unused images until we've freed up enough space.</span></span><br><span class="line"><span class="keyword">var</span> deletionErrors []error</span><br><span class="line">spaceFreed := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, image := <span class="keyword">range</span> images &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">"Evaluating image ID %s for possible garbage collection"</span>, image.id)</span><br><span class="line"><span class="comment">// Images that are currently in used were given a newer lastUsed.</span></span><br><span class="line"><span class="keyword">if</span> image.lastUsed.Equal(freeTime) || image.lastUsed.After(freeTime) &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">"Image ID %s has lastUsed=%v which is &gt;= freeTime=%v, not eligible for garbage collection"</span>, image.id, image.lastUsed, freeTime)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Avoid garbage collect the image if the image is not old enough.</span></span><br><span class="line"><span class="comment">// In such a case, the image may have just been pulled down, and will be used by a container right away.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> freeTime.Sub(image.firstDetected) &lt; im.policy.MinAge &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">"Image ID %s has age %v which is less than the policy's minAge of %v, not eligible for garbage collection"</span>, image.id, freeTime.Sub(image.firstDetected), im.policy.MinAge)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove image. Continue despite errors.</span></span><br><span class="line">klog.Infof(<span class="string">"[imageGCManager]: Removing image %q to free %d bytes"</span>, image.id, image.size)</span><br><span class="line">err := im.runtime.RemoveImage(container.ImageSpec&#123;Image: image.id&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">deletionErrors = <span class="built_in">append</span>(deletionErrors, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(im.imageRecords, image.id)</span><br><span class="line">spaceFreed += image.size</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> spaceFreed &gt;= bytesToFree &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(deletionErrors) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> spaceFreed, fmt.Errorf(<span class="string">"wanted to free %d bytes, but freed %d bytes space with errors in image deletion: %v"</span>, bytesToFree, spaceFreed, errors.NewAggregate(deletionErrors))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> spaceFreed, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="磁盘驱逐与-ImageGC"><a href="#磁盘驱逐与-ImageGC" class="headerlink" title="磁盘驱逐与 ImageGC"></a>磁盘驱逐与 ImageGC</h3><p>除了上述 GC 逻辑外，实际上还有额外的 ImageGC 触发条件。在运行中，偶尔会遇到 ImageGCHighThresholdPercent 被设置为 100 但还是有镜像被清理的情况。我们反过来看下在上文提到的 ImageGC 的接口，可以看到 DeleteUnusedImages 是个 public 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildSignalToNodeReclaimFuncs</span><span class="params">(imageGC ImageGC, containerGC ContainerGC, withImageFs <span class="keyword">bool</span>)</span> <span class="title">map</span>[<span class="title">evictionapi</span>.<span class="title">Signal</span>]<span class="title">nodeReclaimFuncs</span></span> &#123;</span><br><span class="line">signalToReclaimFunc := <span class="keyword">map</span>[evictionapi.Signal]nodeReclaimFuncs&#123;&#125;</span><br><span class="line"><span class="comment">// usage of an imagefs is optional</span></span><br><span class="line"><span class="keyword">if</span> withImageFs &#123;</span><br><span class="line"><span class="comment">// with an imagefs, nodefs pressure should just delete logs</span></span><br><span class="line">signalToReclaimFunc[evictionapi.SignalNodeFsAvailable] = nodeReclaimFuncs&#123;&#125;</span><br><span class="line">signalToReclaimFunc[evictionapi.SignalNodeFsInodesFree] = nodeReclaimFuncs&#123;&#125;</span><br><span class="line"><span class="comment">// with an imagefs, imagefs pressure should delete unused images</span></span><br><span class="line">signalToReclaimFunc[evictionapi.SignalImageFsAvailable] = nodeReclaimFuncs&#123;containerGC.DeleteAllUnusedContainers, imageGC.DeleteUnusedImages&#125;</span><br><span class="line">signalToReclaimFunc[evictionapi.SignalImageFsInodesFree] = nodeReclaimFuncs&#123;containerGC.DeleteAllUnusedContainers, imageGC.DeleteUnusedImages&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// without an imagefs, nodefs pressure should delete logs, and unused images</span></span><br><span class="line"><span class="comment">// since imagefs and nodefs share a common device, they share common reclaim functions</span></span><br><span class="line">signalToReclaimFunc[evictionapi.SignalNodeFsAvailable] = nodeReclaimFuncs&#123;containerGC.DeleteAllUnusedContainers, imageGC.DeleteUnusedImages&#125;</span><br><span class="line">signalToReclaimFunc[evictionapi.SignalNodeFsInodesFree] = nodeReclaimFuncs&#123;containerGC.DeleteAllUnusedContainers, imageGC.DeleteUnusedImages&#125;</span><br><span class="line">signalToReclaimFunc[evictionapi.SignalImageFsAvailable] = nodeReclaimFuncs&#123;containerGC.DeleteAllUnusedContainers, imageGC.DeleteUnusedImages&#125;</span><br><span class="line">signalToReclaimFunc[evictionapi.SignalImageFsInodesFree] = nodeReclaimFuncs&#123;containerGC.DeleteAllUnusedContainers, imageGC.DeleteUnusedImages&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> signalToReclaimFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，在磁盘满导致节点驱逐信号触发时会直接调用容器和镜像的 GC 方法，毕竟节点驱逐的触发是更紧急的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来看，Kubelet 会在<strong>节点驱逐信号触发</strong>和<strong>Image 对应的 Filesystem 空间不足</strong>的情况下删除冗余的镜像。整个 GC 的要点如下：</p><ul><li>清理的触发为到达 HighThresholdPercent 开始清理，一直清理到 LowThresholdPercent 为止。但是需要注意的是通过将 HighThresholdPercent 设置为 100 关闭 GC 的做法对节点驱逐不生效，只能关闭定时清理任务</li><li>镜像清理过程中，有三类镜像不会被清除：<ul><li>Sanbox 所需镜像；</li><li>GC 首次探测和刚被刷新过最后使用时间的镜像；</li><li>探测累计时长小于 MinimumGCAge 的镜像。</li></ul></li><li>清理过程会优先清除最久没用到的和最早探测到的镜像。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Image-GC-是什么？&quot;&gt;&lt;a href=&quot;#Image-GC-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Image GC 是什么？&quot;&gt;&lt;/a&gt;Image GC 是什么？&lt;/h2&gt;&lt;p&gt;Image GC 是 kubelet 的镜像清理功能
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://study4.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Kubernetes" scheme="https://study4.fun/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>博客写作的工作流</title>
    <link href="https://study4.fun/2021-01-02-blogs-workflow/"/>
    <id>https://study4.fun/2021-01-02-blogs-workflow/</id>
    <published>2021-01-02T15:47:00.000Z</published>
    <updated>2022-05-21T07:33:16.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>一开始就把博客写作叫成一个工作流，是因为我们很多时候在写博客的时候，懒惰的很大一部分原因是因为觉得麻烦。当你在使用 hexo 这种静态博客的时候，难免会觉得写作是一件很繁琐的时间，首先会受限于写作环境，其次每次写作都需要“写 md –&gt; 插入图片上传 –&gt; 预览后编译 –&gt; 推送到 pages”。因为工作的原因，用了很久的语雀，感觉语雀的写作体验和管理都是很棒的。那么，如何拥有语雀写作的体验，又能够免去博客更新的繁碎流程呢？</p><h2 id="关于工作流"><a href="#关于工作流" class="headerlink" title="关于工作流"></a>关于工作流</h2><p>实现配置的文章网上一堆，我就不当个搬运工了，说下整个流程吧：</p><ol><li>在语雀的指定仓库写文章，勾选发布的“文档有较大更新，推送给关注知识库的人”</li><li>你在该仓库下设置的 WebHook 触发云平台上的函数服务</li><li>函数服务发送对应的请求给 Github 的 repo dispatch</li><li>dispatch 触发 Github Action，开始构建网页并推送到目标平台（Pages/COS/OSS)，推送完毕后自动刷新 CDN</li></ol><p>完成后，获得的是这样的一套写作平台体验：</p><ol><li>复用了语雀优秀的文档写作和管理体验，做到 Write Every Where</li><li>除了域名外，几乎全免费</li><li>省去了博客的维护成本（<del>Serverless？</del>）</li></ol><p>当然了，初次配置的成本也是不低的。不过对于程序员来说，哪怕首次配置麻烦，后面能省掉很多时间成本也是一件很赚的事情吧。（何况语雀比本地 markdown 好用多了）而且每次写作不用限制在某一台电脑上。</p><h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><ol><li>语雀的 TOKEN 权限设置为只读就 OK</li><li>可以使用语雀作为图床<del>白嫖一下</del>，需要额外配置一下语雀的防盗链</li><li>国内的收录需要博客在国内可访问，使用 Pages+CDN 可以达到效果，又拍云免费</li><li>https 证书操作比较麻烦，可以用第三方网站签发免费的泛域名证书，只是记得定时要在 CDN 上去配置</li><li>刷新 CDN 的 API 调用记得配置全站路径</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/x-cold/yuque-hexo" target="_blank" rel="noopener">语雀知识库同步工具</a><br><a href="https://blog.csdn.net/z_johnny/article/details/104629805/" target="_blank" rel="noopener">Hexo：语雀云端写作，Github Actions 持续集成</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;一开始就把博客写作叫成一个工作流，是因为我们很多时候在写博客的时候，懒惰的很大一部分原因是因为觉得麻烦。当你在使用 hexo 这种静态博客的
      
    
    </summary>
    
    
      <category term="杂项" scheme="https://study4.fun/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="杂项" scheme="https://study4.fun/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>CGroup初探</title>
    <link href="https://study4.fun/2020-10-30-cgroup-startings/"/>
    <id>https://study4.fun/2020-10-30-cgroup-startings/</id>
    <published>2020-10-30T12:55:00.000Z</published>
    <updated>2022-05-21T07:33:16.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>namespace：隔离进程组之间的资源<br>cgroup：对一组进程进行统一的资源监控和限制，进程按组进行管理的机制<br>cgroup 的构成：</p><ul><li>subsystem：对应内核模块，用于对进程组进行操作。</li><li>hierarchy：一棵 cgroup 树，用于进程分组。</li></ul><p>其他：</p><ul><li>在任意一个 hierarchy 内包含 linux 系统的所有 process。</li><li>在同一个 hierarchy 内，process 属于唯一的 process group。但 process 可以存在于不同的 hierarchy 中。</li><li>hierarchy 会对应若干不同的 subsystem（可以为 0），一个 subsystem 只能关联一个 hierarchy。systemd 没有对应的 subsystem。</li></ul><p>process -&gt; process group（cgroup） -&gt; hierarchy<br>树节点       -&gt; 树</p><h2 id="Subsystem"><a href="#Subsystem" class="headerlink" title="Subsystem"></a>Subsystem</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/379285/1609611030134-1deb3af4-31eb-4e24-9ae3-d2be6e440fda.png#height=238&id=Dkmoe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=1056&originalType=binary&size=128629&status=done&style=none&width=528" alt="image.png"><br>subsystem name<br>subsystem 关联 hierarchy id：如果为 0，无绑定/cgroup v2 绑定/未被内核开启<br>num of cgroups：关联 hierarchy 内进程组个数<br>enabled：是否开启，通过内核参数 cgroup_disable 调整</p><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h3><p>cpu (since Linux 2.6.24; CONFIG_CGROUP_SCHED)<br>用来限制 cgroup 的 CPU 使用率。</p><p>cpuacct (since Linux 2.6.24; CONFIG_CGROUP_CPUACCT)<br>统计 cgroup 的 CPU 的使用率。</p><p>cpuset (since Linux 2.6.24; CONFIG_CPUSETS)<br>绑定 cgroup 到指定 CPUs 和 NUMA 节点。</p><p>memory (since Linux 2.6.25; CONFIG_MEMCG)<br>统计和限制 cgroup 的内存的使用率，包括 process memory, kernel memory, 和 swap。</p><p>devices (since Linux 2.6.26; CONFIG_CGROUP_DEVICE)<br>限制 cgroup 创建(mknod)和访问设备的权限。</p><p>freezer (since Linux 2.6.28; CONFIG_CGROUP_FREEZER)<br>suspend 和 restore 一个 cgroup 中的所有进程。</p><p>net_cls (since Linux 2.6.29; CONFIG_CGROUP_NET_CLASSID)<br>将一个 cgroup 中进程创建的所有网络包加上一个 classid 标记，用于 tc 和 iptables。 只对发出去的网络包生效，对收到的网络包不起作用。</p><p>blkio (since Linux 2.6.33; CONFIG_BLK_CGROUP)<br>限制 cgroup 访问块设备的 IO 速度。</p><p>perf_event (since Linux 2.6.39; CONFIG_CGROUP_PERF)<br>对 cgroup 进行性能监控</p><p>net_prio (since Linux 3.3; CONFIG_CGROUP_NET_PRIO)<br>针对每个网络接口设置 cgroup 的访问优先级。</p><p>hugetlb (since Linux 3.5; CONFIG_CGROUP_HUGETLB)<br>限制 cgroup 的 huge pages 的使用量。</p><p>pids (since Linux 4.3; CONFIG_CGROUP_PIDS)<br>限制一个 cgroup 及其子孙 cgroup 中的总进程数。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 挂载一颗和cpuset subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</span><br><span class="line">mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</span><br><span class="line">mount -t cgroup -o cpuset xxx &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</span><br><span class="line"></span><br><span class="line"># 不关联任何子系统</span><br><span class="line">mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd</span><br><span class="line">mount -t cgroup -o none,name&#x3D;systemd xxx &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd</span><br><span class="line"></span><br><span class="line"># 关联所有子系统</span><br><span class="line">mount -t cgroup xxx &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br></pre></td></tr></table></figure><p>查看进程对应的 cgroup<br>proc/[pid]/cgroup<br><img src="https://cdn.nlark.com/yuque/0/2021/png/379285/1609611030153-705d8e96-d042-4333-83b2-066295131056.png#height=211&id=zKDYC&margin=%5Bobject%20Object%5D&name=image.png&originHeight=422&originWidth=812&originalType=binary&size=110989&status=done&style=none&width=406" alt="image.png"><br>hierarchy id : subsystems : 进程在 hierarchy 中的相对路径</p><h3 id="创建管理-cgroup"><a href="#创建管理-cgroup" class="headerlink" title="创建管理 cgroup"></a>创建管理 cgroup</h3><h4 id="cgroup-目录"><a href="#cgroup-目录" class="headerlink" title="cgroup 目录"></a>cgroup 目录</h4><ul><li>cgroup.clone_children<br>这个文件只对 cpuset subsystem 有影响，当该文件的内容为 1 时，新创建的 cgroup 将会继承父 cgroup 的配置，即从父 cgroup 里面拷贝配置文件来初始化新 cgroup，可以参考<a href="https://lkml.org/lkml/2010/7/29/368" target="_blank" rel="noopener">这里</a></li><li>cgroup.procs<br>当前 cgroup 中的所有进程 ID，系统不保证 ID 是顺序排列的，且 ID 有可能重复</li><li>cgroup.sane_behavior<br>具体功能不详，可以参考<a href="https://lkml.org/lkml/2014/7/2/684" target="_blank" rel="noopener">这里</a>和<a href="https://lkml.org/lkml/2014/7/2/686" target="_blank" rel="noopener">这里</a></li><li>notify_on_release<br>该文件的内容为 1 时，当 cgroup 退出时（不再包含任何进程和子 cgroup），将调用 release_agent 里面配置的命令。新 cgroup 被创建时将默认继承父 cgroup 的这项配置。</li><li>release_agent<br>里面包含了 cgroup 退出（移出）时将会执行的命令，系统调用该命令时会将相应 cgroup 的相对路径当作参数传进去。 注意：这个文件只会存在于 root cgroup 下面，其他 cgroup 里面不会有这个文件。</li><li>tasks<br>当前 cgroup 中的所有线程 ID，系统不保证 ID 是顺序排列的</li></ul><h4 id="创建子-cgroup"><a href="#创建子-cgroup" class="headerlink" title="创建子 cgroup"></a>创建子 cgroup</h4><p>新建子文件夹</p><h4 id="添加进程"><a href="#添加进程" class="headerlink" title="添加进程"></a>添加进程</h4><ul><li>在一颗 cgroup 树里面，一个进程必须要属于一个 cgroup。</li><li>新创建的子进程将会自动加入父进程所在的 cgroup</li><li>从一个 cgroup 移动一个进程到另一个 cgroup 时，只要有目的 cgroup 的写入权限就可以了，系统不会检查源 cgroup 里的权限。</li><li>用户只能操作属于自己的进程，不能操作其他用户的进程，root 账号除外</li></ul><blockquote><p>打印当前 shell pid<br>echo $$</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &#39;echo 1421 &gt; ..&#x2F;cgroup.procs&#39;</span><br></pre></td></tr></table></figure><p>将 pid 写入，即是进程加入 cgroup。pid 不可在文件中删除，只可以被转移。因为 在一颗 cgroup 树里面，一个进程必须要属于一个 cgroup</p><h2 id="Pid-Subsystem"><a href="#Pid-Subsystem" class="headerlink" title="Pid Subsystem"></a>Pid Subsystem</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/379285/1609611030141-540a7a9d-785b-4859-b223-55a1f8a99de2.png#height=41&id=VA576&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=1760&originalType=binary&size=55517&status=done&style=none&width=880" alt="image.png"><br>pids.current: 表示当前 cgroup 及其所有子孙 cgroup 中现有的总的进程数量<br>pids.max: 当前 cgroup 及其所有子孙 cgroup 中所允许创建的总的最大进程数量<br><img src="https://cdn.nlark.com/yuque/0/2021/png/379285/1609611030137-e094db9d-da72-4286-a123-da0164c6e0bf.png#height=55&id=LF5mR&margin=%5Bobject%20Object%5D&name=image.png&originHeight=110&originWidth=550&originalType=binary&size=35444&status=done&style=none&width=275" alt="image.png"><br>通过写入 pids.max 限制成功</p><ul><li>子孙 cgroup 中的 pids.max 大小不能超过父 cgroup 中的大小</li><li>子 cgroup 中的进程数不仅受自己的 pids.max 的限制，还受祖先 cgroup 的限制</li></ul><p>pids.current &gt; pids.max 出现的情况：</p><ul><li>设置 pids.max 时，将其值设置的已经比 pids.current 小</li><li>pids.max 只会在当前 cgroup 中的进程 fork、clone 的时候生效，将其他进程加入到当前 cgroup 时，不会检测 pids.max</li></ul><h2 id="Memory-Subsystem"><a href="#Memory-Subsystem" class="headerlink" title="Memory Subsystem"></a>Memory Subsystem</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/379285/1609611030139-a42c4662-4a71-4467-86f4-5ae2c3df8c2b.png#height=174&id=vHiO8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=348&originWidth=2044&originalType=binary&size=320958&status=done&style=none&width=1022" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cgroup.event_control       #用于eventfd的接口</span><br><span class="line"> memory.usage_in_bytes      #显示当前已用的内存</span><br><span class="line"> memory.limit_in_bytes      #设置&#x2F;显示当前限制的内存额度</span><br><span class="line"> memory.failcnt             #显示内存使用量达到限制值的次数</span><br><span class="line"> memory.max_usage_in_bytes  #历史内存最大使用量</span><br><span class="line"> memory.soft_limit_in_bytes #设置&#x2F;显示当前限制的内存软额度</span><br><span class="line"> memory.stat                #显示当前cgroup的内存使用情况</span><br><span class="line"> memory.use_hierarchy       #设置&#x2F;显示是否将子cgroup的内存使用情况统计到当前cgroup里面</span><br><span class="line"> memory.force_empty         #触发系统立即尽可能的回收当前cgroup中可以回收的内存</span><br><span class="line"> memory.pressure_level      #设置内存压力的通知事件，配合cgroup.event_control一起使用</span><br><span class="line"> memory.swappiness          #设置和显示当前的swappiness</span><br><span class="line"> memory.move_charge_at_immigrate #设置当进程移动到其他cgroup中时，它所占用的内存是否也随着移动过去</span><br><span class="line"> memory.oom_control         #设置&#x2F;显示oom controls相关的配置</span><br><span class="line"> memory.numa_stat           #显示numa相关的内存</span><br></pre></td></tr></table></figure><p>设置了内存限制立即生效 –&gt; 物理内存使用量达到 limit –&gt; memory.failcnt +1 –&gt; 内核会尽量将物理内存中的数据移到 swap 空间上去 –&gt; 设置的 limit 过小，或者 swap 空间不足 –&gt; kill 掉 cgroup 内继续申请内存的进程（默认行为）<br><a href="https://segmentfault.com/a/1190000008125359" target="_blank" rel="noopener">详细</a>链接</p><p>##</p><h2 id="CPU-Subsystem"><a href="#CPU-Subsystem" class="headerlink" title="CPU Subsystem"></a>CPU Subsystem</h2><p>cfs_period_us：时间周期长度<br>cfs_quota_us：在一个周期长度内所能使用的 CPU 时间数<br>cpu.shares：</p><ul><li>针对所有的 CPU 的相对值，默认值是 1024</li><li>仅在 CPU 忙时起作用</li><li>无法精确的控制 CPU 使用率，因为 cgroup 会动态变化</li></ul><p>limit_in_cores = cfs_period_us / cfs_quota_us</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://segmentfault.com/a/1190000006917884" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006917884</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;namespace：隔离进程组之间的资源&lt;br&gt;cgroup：对一组进程进行统一的资源监控和限制，进程按组进行管理的机制&lt;b
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://study4.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="容器" scheme="https://study4.fun/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="cgroup" scheme="https://study4.fun/tags/cgroup/"/>
    
  </entry>
  
  <entry>
    <title>QoS in Kubernetes</title>
    <link href="https://study4.fun/2020-10-26-qos-in-kubernetes/"/>
    <id>https://study4.fun/2020-10-26-qos-in-kubernetes/</id>
    <published>2020-10-26T05:55:00.000Z</published>
    <updated>2022-05-21T07:33:16.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-原则"><a href="#1-原则" class="headerlink" title="1.原则"></a>1.原则</h2><ul><li>通过 limit 保证不同 pod 只能占用指定的资源</li><li>集群资源允许被超额分配</li><li>为 pod 划分等级确保不同的 QoS，资源不足时，低等级的会被清理</li></ul><h2 id="2-语义"><a href="#2-语义" class="headerlink" title="2.语义"></a>2.语义</h2><h3 id="limits"><a href="#limits" class="headerlink" title="limits"></a>limits</h3><p>系统允许容器运行时可能使用的资源量的最高上限<br>最多允许使用的上限，超过时进程会被杀掉</p><h3 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h3><p>K8S 调度时能为容器提供的完全可保障的资源量<br>最少的资源下限，当 node 上资源少于该值，pod 将不会被调度到此 node 上</p><blockquote><p>m=milli unit，表示千分之一<br>M=1000</p></blockquote><h2 id="3-资源范围"><a href="#3-资源范围" class="headerlink" title="3.资源范围"></a>3.资源范围</h2><p>cpu/mem/gpu/huge-page(v1.14)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="attr">limits:</span></span><br><span class="line">  <span class="attr">hugepages-2Mi:</span> <span class="string">100Mi</span></span><br></pre></td></tr></table></figure><h2 id="4-基于-request-和-limit-的调度机制"><a href="#4-基于-request-和-limit-的调度机制" class="headerlink" title="4.基于 request 和 limit 的调度机制"></a>4.基于 request 和 limit 的调度机制</h2><p>调度时不看实际的使用资源量，看已运行 pod 的 request 总和作为已占用资源的度量</p><h3 id="K8S-pod-资源的特点"><a href="#K8S-pod-资源的特点" class="headerlink" title="K8S pod 资源的特点"></a>K8S pod 资源的特点</h3><p>分为 <strong>完全可靠资源</strong> 和 <strong>不可靠资源，</strong>通过这种机制实现 <strong>超卖</strong><br>完全可靠的资源 = request<br>不可靠资源 = limit - request</p><h3 id="可压缩-不可压缩资源"><a href="#可压缩-不可压缩资源" class="headerlink" title="可压缩/不可压缩资源"></a>可压缩/不可压缩资源</h3><h4 id="可压缩资源：CPU"><a href="#可压缩资源：CPU" class="headerlink" title="可压缩资源：CPU"></a>可压缩资源：CPU</h4><p>空闲资源按照 Request 的比例进行分配<br>pod 的 cpu 使用超过 limit 时，cgroups 会对 pod 进行限流 throttled</p><h4 id="不可压缩资源：内存"><a href="#不可压缩资源：内存" class="headerlink" title="不可压缩资源：内存"></a>不可压缩资源：内存</h4><p>超过 request 可能会被杀掉<br>超过 limit 时，内核会杀掉容器中使用内存最多的一个，直到不超过 limnit 为止</p><h2 id="5-服务质量等级-QoS-Class"><a href="#5-服务质量等级-QoS-Class" class="headerlink" title="5. 服务质量等级 QoS Class"></a>5. 服务质量等级 QoS Class</h2><p>优先级递减：Guaranteed &gt; Burstable &gt; BestEffort</p><h3 id="Guaranteed"><a href="#Guaranteed" class="headerlink" title="Guaranteed"></a>Guaranteed</h3><p>所有容器 request=limit（仅设置 Limit 时也等效）</p><h3 id="Burstable"><a href="#Burstable" class="headerlink" title="Burstable"></a>Burstable</h3><p>requests 不等于 limits</p><h3 id="BestEffort"><a href="#BestEffort" class="headerlink" title="BestEffort"></a>BestEffort</h3><p>所有容器的 request 和 limit 都未定义</p><h3 id="OOM-Score"><a href="#OOM-Score" class="headerlink" title="OOM Score"></a>OOM Score</h3><p>OOM Score = 内存占用百分比 * 10 + 调整分（OOM_SCORE_ADJ)</p><h4 id="OOM-SCORE-ADJ"><a href="#OOM-SCORE-ADJ" class="headerlink" title="OOM_SCORE_ADJ"></a>OOM_SCORE_ADJ</h4><p>Guaranteed: -998, BestEffort: 1000,<br>Busrtable:</p><ul><li>request &gt; 99.8%内存, 2</li><li>&lt;，1000 - 内存占用百分比 * 10</li><li>request=0, 999</li></ul><h4 id="特殊的-OOM-SCORE"><a href="#特殊的-OOM-SCORE" class="headerlink" title="特殊的 OOM_SCORE"></a>特殊的 OOM_SCORE</h4><p>kubelet/docker: -998<br>不会被杀掉的进程： -999</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-原则&quot;&gt;&lt;a href=&quot;#1-原则&quot; class=&quot;headerlink&quot; title=&quot;1.原则&quot;&gt;&lt;/a&gt;1.原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通过 limit 保证不同 pod 只能占用指定的资源&lt;/li&gt;
&lt;li&gt;集群资源允许被超额分配&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="备忘录" scheme="https://study4.fun/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="读书笔记" scheme="https://study4.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kubernetes" scheme="https://study4.fun/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>APUE读书笔记（一）</title>
    <link href="https://study4.fun/2020-08-15-apue-readling-notes-1/"/>
    <id>https://study4.fun/2020-08-15-apue-readling-notes-1/</id>
    <published>2020-08-15T15:55:00.000Z</published>
    <updated>2022-05-21T07:33:16.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h1><h2 id="1-1-体系结构"><a href="#1-1-体系结构" class="headerlink" title="1.1 体系结构"></a>1.1 体系结构</h2><p>系统调用：内核的接口<br>应用程序既可以使用共用函数库，也可以使用系统调用</p><h2 id="1-2-登录"><a href="#1-2-登录" class="headerlink" title="1.2 登录"></a>1.2 登录</h2><p>登录项的组成：登录名、加密口令、数字用户 ID（UID）、数字组 ID（GID）、注释字段、起始目录、shell 程序</p><h2 id="1-3-目录"><a href="#1-3-目录" class="headerlink" title="1.3 目录"></a>1.3 目录</h2><p>每个进程都有一个工作目录（当前工作目录），相对路径都从工作目录开始解析<br>进程可以使用 chdir 函数更改工作目录</p><h2 id="1-4-输入输出"><a href="#1-4-输入输出" class="headerlink" title="1.4 输入输出"></a>1.4 输入输出</h2><h3 id="1-4-1-文件描述符"><a href="#1-4-1-文件描述符" class="headerlink" title="1.4.1 文件描述符"></a>1.4.1 文件描述符</h3><p>文件描述符是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表<br>取值范围为 0 到 OPEN_MAX（每个进程最多可以打开 的文件数-1，63）</p><h3 id="1-4-2-标准输入、标准输出和标准错误"><a href="#1-4-2-标准输入、标准输出和标准错误" class="headerlink" title="1.4.2 标准输入、标准输出和标准错误"></a>1.4.2 标准输入、标准输出和标准错误</h3><p>标准输入、标准输出和标准错误是在运行新程序时，shell 为程序默认打开的 3 个文件描述符</p><h2 id="1-5-程序和进程"><a href="#1-5-程序和进程" class="headerlink" title="1.5 程序和进程"></a>1.5 程序和进程</h2><p>内核使用 exec 函数将程序读入内存并执行程序<br>fork 函数创建一个新进程，该进程（子进程）是调用进程（父进程）的一个副本<br>在创建时，对父进程返回子进程 ID，对子进程返回 0</p><h2 id="1-6-线程"><a href="#1-6-线程" class="headerlink" title="1.6 线程"></a>1.6 线程</h2><p>一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性</p><h2 id="1-7-出错处理"><a href="#1-7-出错处理" class="headerlink" title="1.7 出错处理"></a>1.7 出错处理</h2><p>errno：Unix 系统函数出错时返回的负值<br>关于 errno：</p><ul><li>如果没有出错，其值都不会被例程清除</li><li>任何函数都不会将 errno 设置为 0</li></ul><p>关于错误：</p><ul><li>出错分为致命性的和非致命性的</li><li>对于致命性错误，可打印出错消息或者写入日志</li><li>对于非致命错误，可以尝试重试（延时、指数补偿算法）</li></ul><h2 id="1-8-用户标识"><a href="#1-8-用户标识" class="headerlink" title="1.8 用户标识"></a>1.8 用户标识</h2><h3 id="1-用户-ID"><a href="#1-用户-ID" class="headerlink" title="1. 用户 ID"></a>1. 用户 ID</h3><p>用户不可更改其用户 ID<br>用户 ID 为 0 的用户为 root 用户或超级用户</p><h3 id="2-组-ID"><a href="#2-组-ID" class="headerlink" title="2. 组 ID"></a>2. 组 ID</h3><p>组文件将组名映射为数字的组 ID，位于/etc/group</p><h3 id="3-附属组-ID"><a href="#3-附属组-ID" class="headerlink" title="3. 附属组 ID"></a>3. 附属组 ID</h3><p>系统允许用户属于另外一些组，一个用户属于多至 16 个其他的组</p><h2 id="1-9-信号"><a href="#1-9-信号" class="headerlink" title="1.9 信号"></a>1.9 信号</h2><p>信号用于通知进程发生了某种状况<br>处理信号的方式：</p><ul><li>忽略</li><li>系统默认方式处理</li><li>提供函数，信号发生时调用，即捕捉信号</li></ul><h2 id="1-10-时间"><a href="#1-10-时间" class="headerlink" title="1.10 时间"></a>1.10 时间</h2><p>日历时间：自 UTC 时间的秒数累计值<br>进程时间：也叫做 CPU 时间，用来度量进程使用的 CPU 资源，以时钟 tick 计算<br>系统为进程维护的三个进程时间值：</p><ul><li>时钟时间，进程运行的时间总量（与系统同时运行的进程数有关）</li><li>用户 CPU 时间，执行用户指令所用的时间量</li><li>系统 CPU 时间，为该进程执行内核程序经历的时间量</li></ul><p>用户 CPU 时间和系统 CPU 时间常称为 CPU 时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 度量执行时间</span><br><span class="line">time -p &lt;command&gt;</span><br></pre></td></tr></table></figure><h2 id="1-11-系统调用和库函数"><a href="#1-11-系统调用和库函数" class="headerlink" title="1.11 系统调用和库函数"></a>1.11 系统调用和库函数</h2><p>系统调用：提供给程序向内核请求服务的，操作系统提供的入口点<br>区别：</p><ul><li>库函数可以被替换，而系统调用通常不可替换</li><li>应用程序既可以调用 系统调用，也可以调用 库函数</li><li>许多库函数会调用系统调用</li><li>系统调用通常是提供最接口，而库函数通常提供较复杂的功能</li><li><strong>进程控制系统调用（fork/exec/wait）</strong>通常有用户应用程序直接调用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-基础知识&quot;&gt;&lt;a href=&quot;#一-基础知识&quot; class=&quot;headerlink&quot; title=&quot;一. 基础知识&quot;&gt;&lt;/a&gt;一. 基础知识&lt;/h1&gt;&lt;h2 id=&quot;1-1-体系结构&quot;&gt;&lt;a href=&quot;#1-1-体系结构&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://study4.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://study4.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Unix" scheme="https://study4.fun/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>《代码整洁之道》笔记</title>
    <link href="https://study4.fun/2020-05-25-clean-coder-notes/"/>
    <id>https://study4.fun/2020-05-25-clean-coder-notes/</id>
    <published>2020-05-25T02:08:00.000Z</published>
    <updated>2022-05-21T07:33:17.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-专业主义"><a href="#1-专业主义" class="headerlink" title="1. 专业主义"></a>1. 专业主义</h2><h3 id="1-1-担当责任"><a href="#1-1-担当责任" class="headerlink" title="1.1 担当责任"></a>1.1 担当责任</h3><h3 id="1-2-不行损害之事"><a href="#1-2-不行损害之事" class="headerlink" title="1.2 不行损害之事"></a>1.2 不行损害之事</h3><p>（1）不要破坏软件功能，让失误率无限接近于 0</p><ul><li>让测试人员找不出问题</li><li>不发布无把握的代码</li><li>反思 bug 怎么越过测试</li><li>确信代码正常运行（自动化测试、单元测试）</li><li>自动化 QA</li></ul><p>（2）不要破坏结构</p><ul><li>不为了发布新功能破坏代码的结构</li><li>软件要易于修改（需要使用测试保证代码可经常修改）</li></ul><h3 id="1-3-职业道德"><a href="#1-3-职业道德" class="headerlink" title="1.3 职业道德"></a>1.3 职业道德</h3><p>职业发展需要保证每周有自己的时间</p><ul><li>领域知识（设计模式、设计原则、方法、实践、工件）</li><li>坚持学习（文章、博客、技术大会）</li><li>练习（每天一到两道题）</li><li>合作</li><li>辅导</li><li>了解业务领域（了解基础架构、基本知识、原则和价值观念）</li><li>站在用户的角度思考</li><li>谦逊</li></ul><h2 id="2-说“不”"><a href="#2-说“不”" class="headerlink" title="2. 说“不”"></a>2. 说“不”</h2><blockquote><p>能就是能，不能就是不能。不要说“试试看”。</p></blockquote><p>作为专业人士，就不应该什么事都照做</p><h3 id="2-1-对抗角色"><a href="#2-1-对抗角色" class="headerlink" title="2.1 对抗角色"></a>2.1 对抗角色</h3><p>面对艰难的决定，直面不同角色的冲突是最好的办法——找到可能的最好结果</p><p>“为什么”其实并没有那么重要</p><h3 id="2-2-高风险时刻"><a href="#2-2-高风险时刻" class="headerlink" title="2.2 高风险时刻"></a>2.2 高风险时刻</h3><p>在高风险时刻说不，是对大家负责</p><h3 id="2-3-团队精神"><a href="#2-3-团队精神" class="headerlink" title="2.3 团队精神"></a>2.3 团队精神</h3><ul><li>不说谎，做出合理预期</li><li>如果是“试试看”，那就代表之前留有余力。本质上是在说谎，可能是为了护住面子和避免冲突</li><li>不消极对抗，不能任由事态发展</li></ul><h3 id="2-4-如何写出好代码"><a href="#2-4-如何写出好代码" class="headerlink" title="2.4 如何写出好代码"></a>2.4 如何写出好代码</h3><p>坚守专业主义精神，说不</p><h2 id="3-说“是”"><a href="#3-说“是”" class="headerlink" title="3. 说“是”"></a>3. 说“是”</h2><h3 id="3-1-承诺用语的三个阶段"><a href="#3-1-承诺用语的三个阶段" class="headerlink" title="3.1 承诺用语的三个阶段"></a>3.1 承诺用语的三个阶段</h3><ul><li>口头上说。缺乏承诺，通常是“需要、但愿、让我们”等</li><li>心里认真。有清晰的事实陈述，明确说明了期限</li><li>真正付诸行动。</li></ul><h3 id="3-2-如何做到“言必信，行必果”"><a href="#3-2-如何做到“言必信，行必果”" class="headerlink" title="3.2 如何做到“言必信，行必果”"></a>3.2 如何做到“言必信，行必果”</h3><ul><li>如果目标依赖于他人，就应该采取具体行动，推动最终目标</li><li>即使感觉目标无法完成，也要弄清楚目标是否能够达成</li><li>如果做不到，就应尽早向承诺对象发起预警</li></ul><h3 id="3-3-如何说“是”"><a href="#3-3-如何说“是”" class="headerlink" title="3.3 如何说“是”"></a>3.3 如何说“是”</h3><p>不说“试试”，直接说出所有的可能性</p><p>坚守原则</p><h2 id="4-编码"><a href="#4-编码" class="headerlink" title="4. 编码"></a>4. 编码</h2><h3 id="4-1-编码需要考虑的问题"><a href="#4-1-编码需要考虑的问题" class="headerlink" title="4.1 编码需要考虑的问题"></a>4.1 编码需要考虑的问题</h3><ul><li>代码正常工作</li><li>解决客户提出的问题——不是需求，需求不一定能解决问题</li><li>和现有的系统能很好的结合</li><li>其他程序员可以读懂你的代码</li><li>不要在疲劳或者焦虑的时候编码</li></ul><h3 id="4-2-流态区"><a href="#4-2-流态区" class="headerlink" title="4.2 流态区"></a>4.2 流态区</h3><p>这种状态下，感觉效率极高、绝无错误</p><p>避免进入流态区，因为这样会进入“放弃顾及全局”的陷阱</p><h3 id="4-3-思路阻塞"><a href="#4-3-思路阻塞" class="headerlink" title="4.3 思路阻塞"></a>4.3 思路阻塞</h3><ul><li>找个搭档结对编程</li><li>创造性输入（PPT、音乐、电影等）</li></ul><h3 id="4-4-调试"><a href="#4-4-调试" class="headerlink" title="4.4 调试"></a>4.4 调试</h3><p>调试和编码一样重要</p><p>TDD 可以减少调试时间</p><h3 id="4-5-保持节奏"><a href="#4-5-保持节奏" class="headerlink" title="4.5 保持节奏"></a>4.5 保持节奏</h3><p>在疲劳的时候应该离开工作</p><p>回家路上把自己从工作中抽离出来</p><p>洗澡时或许会浮现解决方案</p><h3 id="4-6-关于进度延迟"><a href="#4-6-关于进度延迟" class="headerlink" title="4.6 关于进度延迟"></a>4.6 关于进度延迟</h3><ul><li>不盲目期望提前完成</li><li>不盲目冲刺（可以考虑所有情况，缩减交付的范围）</li><li>加班（需要保证有个人有时间、短期加班、有加班失败的后备预案）</li><li>交付失误时不自欺欺人</li><li>定义一个确切的“完成”标准（自动化验收测试）</li></ul><h3 id="4-7-帮助他人"><a href="#4-7-帮助他人" class="headerlink" title="4.7 帮助他人"></a>4.7 帮助他人</h3><ul><li>帮助他人的时候不应付</li><li>学会接受他人的帮助，学会请求帮助</li><li>辅导与寻求辅导</li></ul><h2 id="5-测试驱动开发"><a href="#5-测试驱动开发" class="headerlink" title="5. 测试驱动开发"></a>5. 测试驱动开发</h2><p>三项法则</p><ul><li>在写好失败单元测试前，不要写任何产品代码；</li><li>一旦单元测试失败了，就不要写测试代码；</li><li>产品代码只需要恰好能够让当前失败的单元测试通过即可，不要多写。</li></ul><p>优势</p><ul><li>确定性；对代码的掌控程度高。</li><li>缺陷注入率；降低代码的 bug 和风险。</li><li>勇气；测试完备，修改或者重构的风险降低。</li><li>文档；单元测试即示例，清晰准确。</li><li>设计；迫使自己考虑好的设计。</li></ul><h2 id="6-练习"><a href="#6-练习" class="headerlink" title="6. 练习"></a>6. 练习</h2><h3 id="6-1-练习方式"><a href="#6-1-练习方式" class="headerlink" title="6.1 练习方式"></a>6.1 练习方式</h3><h4 id="kata"><a href="#kata" class="headerlink" title="kata"></a>kata</h4><p>练习解决这个问题所需要的动作和决策</p><p>学习热键和导航操作、测试驱动开的、持续集成之类的方法</p><h4 id="wasa"><a href="#wasa" class="headerlink" title="wasa"></a>wasa</h4><p>两个人的 kata，一个人写单元测试，另一个人写程序</p><h4 id="自由练习"><a href="#自由练习" class="headerlink" title="自由练习"></a>自由练习</h4><p>多人参与的 wasa</p><h3 id="6-2-拓展经验的方法"><a href="#6-2-拓展经验的方法" class="headerlink" title="6.2 拓展经验的方法"></a>6.2 拓展经验的方法</h3><p>开源</p><p>使用自己的时间练习</p><h2 id="7-验收测试"><a href="#7-验收测试" class="headerlink" title="7.验收测试"></a>7.验收测试</h2><h3 id="7-1-需求的沟通"><a href="#7-1-需求的沟通" class="headerlink" title="7.1 需求的沟通"></a>7.1 需求的沟通</h3><p>不要过早精细化需求</p><ul><li>不确定原则（观察者效应）：观察到的新信息会影响对整个系统的看法</li><li>预估焦虑：需求一定会变化，追求早期的精准性是徒劳的</li></ul><p>迟来的模糊性：需求文档中的模糊之处，都对应着业务方的分歧</p><h3 id="7-2-验收测试"><a href="#7-2-验收测试" class="headerlink" title="7.2 验收测试"></a>7.2 验收测试</h3><p>“完成”的含义</p><ul><li>所有的代码写完了</li><li>测试通过了</li><li>QA 和需求方已经认可</li></ul><p>沟通：开发方、业务方、测试方达成共识</p><p>自动化：缩减成本</p><p>测试并不是额外工作</p><p>验收测试与开发应当不是同一个人编写</p><p>开发人员的角色是把验收测试和开发系统联系起来保证测试的通过</p><p>不能被动接收测试，需要协商并改进</p><p>验收测试和单元测试：内部 vs 外部</p><p>图形界面和其他复杂因素：调用 API 而不是 GUI</p><p>持续集成：失败应立刻终止</p><h2 id="8-测试策略"><a href="#8-测试策略" class="headerlink" title="8. 测试策略"></a>8. 测试策略</h2><p>自动化测试金字塔：</p><ul><li>单元测试：在最低层次上定义系统。</li><li>组件测试：对业务规则的验收测试。</li><li>集成测试：装备测试，确认组件之间正确连接，彼此通信畅通。</li><li>系统测试：测试系统是否正确组装完毕，以及各个组件之间是否正确交互，同时包括吞吐量测试和性能测试。</li><li>人工探索式测试：确保系统在人工才操作表现良好。</li></ul><h2 id="9-时间管理"><a href="#9-时间管理" class="headerlink" title="9. 时间管理"></a>9. 时间管理</h2><h3 id="9-1-会议"><a href="#9-1-会议" class="headerlink" title="9.1 会议"></a>9.1 会议</h3><p>学会拒绝/离席，确定议程和目标，立会，迭代计划会议，争论与反对</p><blockquote><p>凡是不能在五分钟内解决的争论，都不能靠辩论解决。<br>唯一的出路是：用数据说话。可以做试验、模仿或者建模。</p></blockquote><h3 id="9-2-注意力点数"><a href="#9-2-注意力点数" class="headerlink" title="9.2 注意力点数"></a>9.2 注意力点数</h3><p>学会安排时间，妥善使用自己的注意力点数</p><p>睡眠/咖啡/恢复/肌肉注意力/输入和输出</p><h3 id="9-3-时间拆分和番茄工作法"><a href="#9-3-时间拆分和番茄工作法" class="headerlink" title="9.3 时间拆分和番茄工作法"></a>9.3 时间拆分和番茄工作法</h3><p>记录下来并画图展示</p><h3 id="9-4-要避免的行为"><a href="#9-4-要避免的行为" class="headerlink" title="9.4 要避免的行为"></a>9.4 要避免的行为</h3><p>优先级错乱——提高某个任务的优先级，有借口推迟真正急迫的任务</p><h3 id="9-5-死胡同"><a href="#9-5-死胡同" class="headerlink" title="9.5 死胡同"></a>9.5 死胡同</h3><p>不执拗于不容放弃也无法绕开的主意，听取其他意见。越是坚持，浪费的时间越多。</p><h3 id="9-6-泥潭"><a href="#9-6-泥潭" class="headerlink" title="9.6 泥潭"></a>9.6 泥潭</h3><p>走回头路是最简单的办法。</p><p>发现身处泥潭还固执前进，是最严重的优先级错乱。</p><h2 id="10-预估"><a href="#10-预估" class="headerlink" title="10. 预估"></a>10. 预估</h2><h3 id="10-1-什么是预估"><a href="#10-1-什么是预估" class="headerlink" title="10.1 什么是预估"></a>10.1 什么是预估</h3><p>承诺还是猜测？</p><p>预估是一种猜测，不包含任何承诺的色彩。不是一个定数，是一种概率分布。</p><p>小心给出暗示性的承诺。</p><h3 id="10-2-PERT（计划评审技术）"><a href="#10-2-PERT（计划评审技术）" class="headerlink" title="10.2 PERT（计划评审技术）"></a>10.2 PERT（计划评审技术）</h3><p>乐观预估（1%），标称预估（概率最大），悲观预估（1%）</p><p>得出任务的<strong>期望完成时间</strong>和任务的<strong>概率分布标准差</strong>（不确定性）</p><h3 id="10-3-预估任务"><a href="#10-3-预估任务" class="headerlink" title="10.3 预估任务"></a>10.3 预估任务</h3><p>德尔菲法：</p><ul><li>亮手指：预估相近达到统一，有分歧则讨论</li><li>规划扑克</li><li>关联预估：多人对任务进行所需时间长短的排序，讨论分歧，任务归类</li><li>三元预估：使用德尔菲法分别进行乐观、标称、悲观预估</li></ul><h3 id="10-4-大数定律"><a href="#10-4-大数定律" class="headerlink" title="10.4 大数定律"></a>10.4 大数定律</h3><p>控制错误的方法——把大任务分成小任务，分开预估在加总，结果会比单独评估大任务要准确的多</p><h2 id="11-压力"><a href="#11-压力" class="headerlink" title="11. 压力"></a>11. 压力</h2><h3 id="11-1-避免压力"><a href="#11-1-避免压力" class="headerlink" title="11.1 避免压力"></a>11.1 避免压力</h3><p>避免对没有把握能够达成的最后期限做出承诺</p><p>让系统、代码和设计尽可能整洁</p><p>在危机时也要遵守纪律原则（例如 TDD）</p><h3 id="11-2-应对压力"><a href="#11-2-应对压力" class="headerlink" title="11.2 应对压力"></a>11.2 应对压力</h3><p>不要惊慌失措：深思熟虑，努力寻找可以带来最好结果的方法</p><p>沟通：告诉你制定的走出困境的计划，请求支援和指引</p><p>坚信纪律和原则</p><p>寻求帮助：结对编程</p><h2 id="12-协作"><a href="#12-协作" class="headerlink" title="12. 协作"></a>12. 协作</h2><p>首要职责是满足雇主的需求，和团队协作，<strong>深刻理解业务目标</strong>，了解企业如何从你的工作中获得回报</p><p>拥有代码的是整个团队，而不是个人</p><p>专业人士会共同工作，彼此面对面。</p><h2 id="13-团队和项目"><a href="#13-团队和项目" class="headerlink" title="13. 团队和项目"></a>13. 团队和项目</h2><p>形成团队需要时间。建立关系，学会互相协作，了解彼此的癖好和长短处，最后凝聚成为团队。</p><p>把项目分配给已经形成凝聚力的团队，而不是围绕项目组建团队。</p><h2 id="14-辅导、实习生和技艺"><a href="#14-辅导、实习生和技艺" class="headerlink" title="14. 辅导、实习生和技艺"></a>14. 辅导、实习生和技艺</h2><p>辅导：</p><ul><li>通过书籍手册向作者学习</li><li>通过观察他人工作来学习</li></ul><p>实习生：</p><ul><li>技术方面你的传授、培训、督导和检查</li></ul><p>技艺：</p><ul><li>技艺的模因包含价值观、原则、技术、态度和正见</li><li>技艺的模因经由口口相传和手手相承而来</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-专业主义&quot;&gt;&lt;a href=&quot;#1-专业主义&quot; class=&quot;headerlink&quot; title=&quot;1. 专业主义&quot;&gt;&lt;/a&gt;1. 专业主义&lt;/h2&gt;&lt;h3 id=&quot;1-1-担当责任&quot;&gt;&lt;a href=&quot;#1-1-担当责任&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://study4.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://study4.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2019的闲言碎语</title>
    <link href="https://study4.fun/2020-01-01-2019-comments/"/>
    <id>https://study4.fun/2020-01-01-2019-comments/</id>
    <published>2020-01-01T08:45:58.000Z</published>
    <updated>2022-05-21T07:33:17.296Z</updated>
    
    <content type="html"><![CDATA[<p>回顾总是有种从时间线开始的惯性。2019 年开始于天津不好吃的本地餐厅，结束于一顿火烧云不好吃的外卖。如同不好吃的饭，其实这一年经历的过程也算不上顺遂心意。</p><h1 id="平行的工作线"><a href="#平行的工作线" class="headerlink" title="平行的工作线"></a>平行的工作线</h1><p>年前的两个月忙着做实验室的项目，年后开始准备实习的事情。我常说自己足够幸运，在应该做某件事的时候就去做了这件事，这样尽力就好。但这也只是在事后对于自己的些微自嘲而已，我还是改不掉过分焦虑的坏毛病。正如高考前失眠，考研前默背政治到半夜，准备实习的我还是经常会自己一个人默默焦虑地胡思乱想到失眠。</p><p>中间经历了其实不算多的面试，因为想要投的岗位对口的其实并不算多。在实验室的经历让我走了一条和别的同学不太一样的岗位，得益于平时的兴趣比较杂比较宽泛，算是很幸运的拿到了实习岗位。其实回顾来看，最后的结果其实是超乎于我自己意料之外的，因为入职后见过身边远远优秀与我的同学太多。</p><p>如果对当前的选择感到迷茫，不如找一个能看清方向的人交流，远比自己尝试碰壁或者和同类人无效讨论要有效得多。希望自己能在以后的经历中谨记住这一点。</p><p>工作了三四个月，回顾下其实觉得收益到最多的反而是工作方式。很多时候，我们抱怨工作枯燥，内容无趣。但总是会有人能从这些枯燥的工作中提取出更有效的东西，提高自己的效率，提高自己的思考深度，这让我真切体会到平凡和优秀的区别。说和做，差的总是很远。</p><p>后面回到学校准备毕设中期，除了完成一篇自己之前觉得有点难度的水论文，倒也没有什么大的波澜。</p><h1 id="平行的生活线"><a href="#平行的生活线" class="headerlink" title="平行的生活线"></a>平行的生活线</h1><p>对于个人生活来说，19 年真的是很重要的一年。不同于工作上能够絮絮叨叨说出个所以然，对于我来说，生活是由一个个或难忘或开心或感动，也或是平凡幸福的时刻组成的。很多个这样的时刻会慢慢沉淀成一种潜移默化的东西，支撑自己在各种困难的时候坚持过去。今年这样的时刻格外的多，或许因为不再是一个人的原因吧。</p><p>如果说要给自己的 2020 寄托一些什么希冀一些什么，大概还是一些意识到却没有做到的东西。</p><ol><li>能够想到就去做，但是还没坚持做下去。</li><li>能够开始反思，但是还没及时改变。</li></ol><p>其实如果能做到这两点，总感觉 2020 就会好。但是人总是有点惰性的，我也还是那个对自己有限悲观的人。接下来的一年，能做到一个，也足够让我满足了。毕竟，顺遂心意永远是最重要的。拧巴地生活，还不如维持现状呢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回顾总是有种从时间线开始的惯性。2019 年开始于天津不好吃的本地餐厅，结束于一顿火烧云不好吃的外卖。如同不好吃的饭，其实这一年经历的过程也算不上顺遂心意。&lt;/p&gt;
&lt;h1 id=&quot;平行的工作线&quot;&gt;&lt;a href=&quot;#平行的工作线&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="日记" scheme="https://study4.fun/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="杂项" scheme="https://study4.fun/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes学习笔记——DesiredStateOfWorldPopulator源码分析</title>
    <link href="https://study4.fun/2019-09-03-desired-state-of-world-populator/"/>
    <id>https://study4.fun/2019-09-03-desired-state-of-world-populator/</id>
    <published>2019-09-03T11:20:00.000Z</published>
    <updated>2022-05-21T07:33:17.064Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，kubelet 启动时会运行 VolumeManager 协程来负责 Volume 变更时的操作。它主要通过 ActualStateOfWorld 和 DesiredStateOfWorld 这两个 cache 信息来让 VolumeManager 中的两个协程工作。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/379285/1589796776766-3a781cca-43cf-4c1a-92d4-7e32d5a48ffe.png#align=left&display=inline&height=618&margin=%5Bobject%20Object%5D&name=3599202506.png&originHeight=618&originWidth=2986&size=54165&status=done&style=none&width=2986" alt="3599202506.png"></p><blockquote><p>DesiredStateOfWorldPopulator 和 Reconciler 两个 Goroutine 会通过图中两个的 StateOfWorld 状态进行通信，DesiredStateOfWorldPopulator 主要负责从 Kubernetes 节点中获取新的 Pod 对象并更新 DesiredStateOfWorld 结构；而后者会根据实际状态和当前状态的区别对当前节点的状态进行迁移，也就是通过 DesiredStateOfWorld 中状态的变更更新 ActualStateOfWorld 中的内容。<br>Ref: <a href="https://draveness.me/kubernetes-volume" target="_blank" rel="noopener">https://draveness.me/kubernetes-volume</a></p></blockquote><p>下面就来分析一下 DesiredStateOfWorldPopulator 的源码。</p><h1 id="0x02-结构与接口"><a href="#0x02-结构与接口" class="headerlink" title="0x02. 结构与接口"></a>0x02. 结构与接口</h1><p>DesiredStateOfWorldPopulator 的数据结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> desiredStateOfWorldPopulator <span class="keyword">struct</span> &#123;</span><br><span class="line">   kubeClient                clientset.Interface</span><br><span class="line">   loopSleepDuration         time.Duration</span><br><span class="line">   getPodStatusRetryDuration time.Duration</span><br><span class="line">   podManager                pod.Manager</span><br><span class="line">   podStatusProvider         status.PodStatusProvider</span><br><span class="line">   desiredStateOfWorld       cache.DesiredStateOfWorld</span><br><span class="line">   actualStateOfWorld        cache.ActualStateOfWorld</span><br><span class="line">   pods                      processedPods</span><br><span class="line">   kubeContainerRuntime      kubecontainer.Runtime</span><br><span class="line">   timeOfLastGetPodStatus    time.Time</span><br><span class="line">   keepTerminatedPodVolumes  <span class="keyword">bool</span></span><br><span class="line">   hasAddedPods              <span class="keyword">bool</span></span><br><span class="line">   hasAddedPodsLock          sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>kubeClient：用以从 API Server 获取 PV 和 PVC 对象</li><li>loopSleepDuration：定义连续执行的间隔</li><li>podManager：host 真实存在的 Pod 信息获取来源</li></ul><p>DesiredStateOfWorldPopulator 的接口有三个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DesiredStateOfWorldPopulator <span class="keyword">interface</span> &#123;</span><br><span class="line">   Run(sourcesReady config.SourcesReady, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">   ReprocessPod(podName volumetypes.UniquePodName)</span><br><span class="line"></span><br><span class="line">   HasAddedPods() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了核心执行方法 Run，ReprocessPod 能够将特定 Pod 强制剔出 processedPods 列表进行强制重新处理。该方法用于在 Pod 更新上启用重新挂载卷。而 HasAddedPods 方法则返回 populator 是否已经将所有现有 Pod 处理添加到 desired state 中。</p><h1 id="0x03-核心流程分析"><a href="#0x03-核心流程分析" class="headerlink" title="0x03. 核心流程分析"></a>0x03. 核心流程分析</h1><h2 id="3-1-populatorLoopFunc"><a href="#3-1-populatorLoopFunc" class="headerlink" title="3.1 populatorLoopFunc"></a>3.1 populatorLoopFunc</h2><p>run 方法中，每隔 loopSleepDuration 就会执行一次 populatorLoopFunc。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dswp *desiredStateOfWorldPopulator)</span> <span class="title">populatorLoopFunc</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      dswp.findAndAddNewPods()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> time.Since(dswp.timeOfLastGetPodStatus) &lt; dswp.getPodStatusRetryDuration &#123;</span><br><span class="line">         glog.V(<span class="number">5</span>).Infof(</span><br><span class="line">            <span class="string">"Skipping findAndRemoveDeletedPods(). Not permitted until %v (getPodStatusRetryDuration %v)."</span>,</span><br><span class="line">            dswp.timeOfLastGetPodStatus.Add(dswp.getPodStatusRetryDuration),</span><br><span class="line">            dswp.getPodStatusRetryDuration)</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      dswp.findAndRemoveDeletedPods()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-findAndAddNewPods"><a href="#3-2-findAndAddNewPods" class="headerlink" title="3.2 findAndAddNewPods"></a>3.2 findAndAddNewPods</h2><p>findAndAddNewPods 遍历所有 Pod 并且将“应该添加到期望状态但实际上没有添加”的 Pod 添加到对应状态值中。</p><p>分析流程可知该方法先寻找不是终止状态的 Pod，再调用 processPodVolumes 处理这些符合条件的 Pod。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dswp *desiredStateOfWorldPopulator)</span> <span class="title">findAndAddNewPods</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, pod := <span class="keyword">range</span> dswp.podManager.GetPods() &#123;</span><br><span class="line">      <span class="keyword">if</span> dswp.isPodTerminated(pod) &#123;</span><br><span class="line">         <span class="comment">// Do not (re)add volumes for terminated pods</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      dswp.processPodVolumes(pod)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终止状态判定生效条件满足一条即判定为终止状态：</p><ul><li>Phase 处于 PodFailed</li><li>Phase 处于 Succeeded</li><li>删除时间不为空，且所有内部容器状态 ContainerStatus 都为 Terminated 或者 Waiting，或者 Container List 为空。</li></ul><p>终止状态判定完毕，核心方法 processPodVolumes 会将给定 Pod 中的 Volumes 进行处理并添加到期望状态值中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processPodVolumes processes the volumes in the given pod and adds them to the desired state of the world.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dswp *desiredStateOfWorldPopulator)</span> <span class="title">processPodVolumes</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   uniquePodName := util.GetUniquePodName(pod)</span><br><span class="line">   <span class="keyword">if</span> dswp.podPreviouslyProcessed(uniquePodName) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   allVolumesAdded := <span class="literal">true</span></span><br><span class="line">   mountsMap, devicesMap := dswp.makeVolumeMap(pod.Spec.Containers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process volume spec for each volume defined in pod</span></span><br><span class="line">   <span class="keyword">for</span> _, podVolume := <span class="keyword">range</span> pod.Spec.Volumes &#123;</span><br><span class="line">      volumeSpec, volumeGidValue, err :=</span><br><span class="line">         dswp.createVolumeSpec(podVolume, pod.Name, pod.Namespace, mountsMap, devicesMap)</span><br><span class="line">      ....</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add volume to desired state of world</span></span><br><span class="line">      _, err = dswp.desiredStateOfWorld.AddPodToVolume(</span><br><span class="line">         uniquePodName, pod, volumeSpec, podVolume.Name, volumeGidValue)</span><br><span class="line"></span><br><span class="line">         ....</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> allVolumesAdded &#123;</span><br><span class="line">      dswp.markPodProcessed(uniquePodName)</span><br><span class="line">      <span class="comment">// New pod has been synced. Re-mount all volumes that need it</span></span><br><span class="line">      dswp.actualStateOfWorld.MarkRemountRequired(uniquePodName)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该方法处理流程如下：</p><ol><li>判断该 Pod 之前是否被处理过，处理过则返回。即从 dswp 的 processedPods 列表中查找，需要加读锁。</li><li>通过 Container 列表创建 mountsMap 和 devicesMap，mountsMap 存储 VolumeMounts 字段的挂载信息，devicesMap 存储 BlockVolume 的信息。Key=VolumeMount.Name，Value=True。</li><li>对 Spec 中的 Volumes 列表中每一项 PodVolume，根据 PodName, Namespace, mountsMap, devicesMap 创建 VolumeSpec。</li><li>根据 Pod,PodName,VolumeSpec， PV Name，GID 将 Volume 添加到 dswp 缓存的 desiredStateOfWorld 中。</li><li>如果全部 Volume 的添加都成功则将 Pod 标记为“Processed”，同时将 Pod 标记为 RemountRequired 状态用以更新 Volume 的内容。</li></ol><p>其中，步骤 3 的 createVolumeSpec 首先会判断该 podVolume 的 Source 是否为 PVC，如果为 PVC 则需要找到 Claim 背后的 PV Name，再通过 PV Name 获取真正的 PV 对象并返回。如果 PVC 为空，则对 PV 深拷贝并创建 Spec 对象返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dswp *desiredStateOfWorldPopulator)</span> <span class="title">getPVCExtractPV</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   namespace <span class="keyword">string</span>, claimName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, types.UID, error)</span></span> &#123;</span><br><span class="line">   pvc, err :=</span><br><span class="line">      dswp.kubeClient.CoreV1().PersistentVolumeClaims(namespace).Get(claimName, metav1.GetOptions&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> || pvc == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>, <span class="string">""</span>, fmt.Errorf(......)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> pvc.Status.Phase != v1.ClaimBound || pvc.Spec.VolumeName == <span class="string">""</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>, <span class="string">""</span>, fmt.Errorf(......)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> pvc.Spec.VolumeName, pvc.UID, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，通过 PVC 找 PV Name 是由 KubeClient 向 API Server 请求得到的。请求通过 Namespace 和 Claim Name 获取到 PVC 对象，确认 PVC 对象的 Phase 为 Bound 状态且 pvc.Spec.VolumeName 不为空。上述流程成功后返回 PVC 的 VolumeName（即 PV Name）和该 PVC 的 UID。</p><p>获取到 pvName 和 pvcUID 后，再次通过 KubeClient 向 API Server 请求得到 PV 对象。请求成功后检查 ClaimRef 是否为空，ClaimRef 的 UID 和传入的 PVC UID 是否一致。最后返回该 PV 对象，在返回的同时一并返回的还有 PV 的 GID。</p><p>再看看步骤 4，其调用的 AddPodToVolume 方法如果检查到没有可用的 Volume 插件或者可用插件不止一个，会返回 Error。如果 Pod Unique Name 重复，则不执行任何操作。此外，如果 Volume Name 如果不在该节点的 Volume 列表中，则该 Volume 会被隐式添加( implicitly added)。</p><blockquote><p>If a volume with the name volumeName does not exist in the list of volumes that should be attached to this node, the volume is implicitly added.</p></blockquote><h2 id="3-3-findAndRemoveDeletedPods"><a href="#3-3-findAndRemoveDeletedPods" class="headerlink" title="3.3 findAndRemoveDeletedPods"></a>3.3 findAndRemoveDeletedPods</h2><p>先从 desiredStateOfWorld 中遍历待挂载的 Volume，然后从 PodManager 中根据待挂载 Volume 的 Pod UID 查找该对应 Pod。跳过正在运行和不需要删除 Volumes（keepTerminatedPodVolumes）的 Pod，执行删除流程。</p><p>当 Pod 从 PodManager 中删除 Pod 时，Pod 不会在 Volume Manager 中立即删除，需要确认 kubelet 容器运行时所有的 Container 已经全部终止。此外，同时还要确认 actualStateOfWorld 缓存中是否存在待挂载 Volume 信息。</p><p>上述确认过程确认完毕后，从 desiredStateOfWorld 缓存中删除 Pod，表明指定的 Pod 不再需要该 Volume。同时，从 dswp 维护的 processedPods 列表中删除该 Pod。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道，kubelet 启动时会运行 VolumeManager 协程来负责 Volume 变更时的操作。它主要通过 ActualStateOfWorld 和 DesiredStateOfWorld 这两个 cache 信息来让 VolumeManager 中的两个协程工
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://study4.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://study4.fun/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kubernetes" scheme="https://study4.fun/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>《基于容器的分布式系统设计模式》读书笔记</title>
    <link href="https://study4.fun/2019-08-29-dpfcds-notes/"/>
    <id>https://study4.fun/2019-08-29-dpfcds-notes/</id>
    <published>2019-08-29T11:27:00.000Z</published>
    <updated>2022-05-21T07:33:16.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式的意义"><a href="#设计模式的意义" class="headerlink" title="设计模式的意义"></a>设计模式的意义</h2><p>让缺少经验的开发者能够更容易地开发出<strong>可复用</strong>且<strong>高效稳定</strong>的程序</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>单容器<br>单节点<br>多节点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设计模式的意义&quot;&gt;&lt;a href=&quot;#设计模式的意义&quot; class=&quot;headerlink&quot; title=&quot;设计模式的意义&quot;&gt;&lt;/a&gt;设计模式的意义&lt;/h2&gt;&lt;p&gt;让缺少经验的开发者能够更容易地开发出&lt;strong&gt;可复用&lt;/strong&gt;且&lt;strong&gt;高效稳
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://study4.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="容器" scheme="https://study4.fun/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="设计模式" scheme="https://study4.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes Java Client代码学习——list all pods</title>
    <link href="https://study4.fun/2019-05-22-list-all-pods/"/>
    <id>https://study4.fun/2019-05-22-list-all-pods/</id>
    <published>2019-05-22T08:08:00.000Z</published>
    <updated>2022-05-21T07:33:17.096Z</updated>
    
    <content type="html"><![CDATA[<p>从官方提供的代码入手，”列出所有 Pod”的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ApiException</span>&#123;</span><br><span class="line">        ApiClient client = Config.defaultClient();</span><br><span class="line">        Configuration.setDefaultApiClient(client);</span><br><span class="line"></span><br><span class="line">        CoreV1Api api = <span class="keyword">new</span> CoreV1Api();</span><br><span class="line">        V1PodList list = api.listPodForAllNamespaces(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (V1Pod item : list.getItems()) &#123;</span><br><span class="line">            System.out.println(item.getMetadata().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，给出一张手绘的流程图。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/379285/1589796525746-9d58cc6b-db3d-4d7b-9f26-610e809620e4.png#align=left&display=inline&height=1183&margin=%5Bobject%20Object%5D&name=2534770445.png&originHeight=1183&originWidth=1810&size=97775&status=done&style=none&width=1810" alt="2534770445.png"></p><h1 id="0x02-核心流程"><a href="#0x02-核心流程" class="headerlink" title="0x02. 核心流程"></a>0x02. 核心流程</h1><h2 id="2-1-创建-ApiClient-对象"><a href="#2-1-创建-ApiClient-对象" class="headerlink" title="2.1 创建 ApiClient 对象"></a>2.1 创建 ApiClient 对象</h2><p>首先是创建 ApiClient 对象，从 defaultClient 方法切入，它返回的是一个由 ClientBuilder 的 standard 方法创建的 ApiClient 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiClient <span class="title">defaultClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ClientBuilder.standard().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-1-Standard-方法"><a href="#2-1-1-Standard-方法" class="headerlink" title="2.1.1 Standard 方法"></a>2.1.1 Standard 方法</h3><p>继续追踪 ClientBuilder 中 Standard 方法的源码，代码注释显示该方法会通过四种预先配置好的方式中的一种创建一个 builder，优先度顺序如下：</p><ol><li>如果环境变量中 KUBECONFIG 定义过，则直接使用该配置；</li><li>如果<code>$HOME/.kube/config</code>可以被找到，则使用该配置；</li><li>如果<code>In-cluster Service Account</code>能被找到的话，则它就承担集群配置的功能；</li><li>上述都不存在，则默认使用<code>localhost：8080</code>作为最后的方法。</li></ol><p>如果配置文件或者对应的配置无效的话，会抛出 ConnectException 异常。下来根据代码来验证以上的注释内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientBuilder <span class="title">standard</span><span class="params">(<span class="keyword">boolean</span> persistConfig)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  #1.首先从环境变量中找ENV_KUBECONFIG</span><br><span class="line">  <span class="keyword">final</span> File kubeConfig = findConfigFromEnv();</span><br><span class="line">  #找到则读取对应配置文件，执行对应加载过程并返回</span><br><span class="line">  <span class="keyword">if</span> (kubeConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> (FileReader kubeConfigReader = <span class="keyword">new</span> FileReader(kubeConfig)) &#123;</span><br><span class="line">      KubeConfig kc = KubeConfig.loadKubeConfig(kubeConfigReader);</span><br><span class="line">      <span class="keyword">if</span> (persistConfig) &#123;</span><br><span class="line">        kc.setPersistConfig(<span class="keyword">new</span> FilePersister(kubeConfig));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> kubeconfig(kc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  #2.其次从Home目录找.kube/config文件</span><br><span class="line">  <span class="keyword">final</span> File config = findConfigInHomeDir();   <span class="comment">//完成目录文件路径的拼接并返回File对象</span></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> (FileReader configReader = <span class="keyword">new</span> FileReader(config)) &#123;</span><br><span class="line">      KubeConfig kc = KubeConfig.loadKubeConfig(configReader);</span><br><span class="line">      <span class="keyword">if</span> (persistConfig) &#123;</span><br><span class="line">        kc.setPersistConfig(<span class="keyword">new</span> FilePersister(config));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> kubeconfig(kc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  #3.采用集群内ServiceCount方式配置，这里传入的是SC对应的证书文件路径</span><br><span class="line">  <span class="keyword">final</span> File clusterCa = <span class="keyword">new</span> File(SERVICEACCOUNT_CA_PATH);</span><br><span class="line">  <span class="keyword">if</span> (clusterCa.exists()) &#123;</span><br><span class="line">    <span class="keyword">return</span> cluster();</span><br><span class="line">  &#125;</span><br><span class="line">  #4.上述方式无效则使用默认构造器方法创建一个实例，实例中DEFAULT_FALLBACK_HOST指定的就是http://localhost:8080</span><br><span class="line">  # private String basePath = Config.DEFAULT_FALLBACK_HOST;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ClientBuilder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到代码中实现与注释一一对应，在第一二种配置方式中，核心的方法主要有 KubeConfig 的 loadKubeConfig 和 setPersistConfig 两个方法。从字面上来看，前者主要负责配置加载，而后者则是对于 PersistConfig 的设置，具体是什么后面再看。</p><p>首先分析 loadKubeConfig 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KubeConfig <span class="title">loadKubeConfig</span><span class="params">(Reader input)</span> </span>&#123;</span><br><span class="line">  #可以看到这里将输入读取为一个yaml对象，</span><br><span class="line">  Yaml yaml = <span class="keyword">new</span> Yaml(<span class="keyword">new</span> SafeConstructor());</span><br><span class="line">  Object config = yaml.load(input);</span><br><span class="line">  #然后将yaml形式的config对象转化为Map</span><br><span class="line">  Map&lt;String, Object&gt; configMap = (Map&lt;String, Object&gt;) config;</span><br><span class="line"></span><br><span class="line">  #通过转化为的map取出对应的五个值</span><br><span class="line">  String currentContext = (String) configMap.get(<span class="string">"current-context"</span>);</span><br><span class="line">  ArrayList&lt;Object&gt; contexts = (ArrayList&lt;Object&gt;) configMap.get(<span class="string">"contexts"</span>);</span><br><span class="line">  ArrayList&lt;Object&gt; clusters = (ArrayList&lt;Object&gt;) configMap.get(<span class="string">"clusters"</span>);</span><br><span class="line">  ArrayList&lt;Object&gt; users = (ArrayList&lt;Object&gt;) configMap.get(<span class="string">"users"</span>);</span><br><span class="line">  Object preferences = configMap.get(<span class="string">"preferences"</span>);</span><br><span class="line"></span><br><span class="line">  #将取出来的值装配到kubeconfig对象里，最后返回</span><br><span class="line">  KubeConfig kubeConfig = <span class="keyword">new</span> KubeConfig(contexts, clusters, users);</span><br><span class="line">  kubeConfig.setContext(currentContext);</span><br><span class="line">  kubeConfig.setPreferences(preferences);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> kubeConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 KubeConfig 类的变量声明能看到一些额外的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到kubeconfig文件的默认地址相关字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENV_HOME = <span class="string">"HOME"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KUBEDIR = <span class="string">".kube"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KUBECONFIG = <span class="string">"config"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Authenticator&gt; authenticators = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者留下的注释</span></span><br><span class="line"><span class="comment">//“致读者：我曾考虑过不使用多个Map，而是创建一个config对象并解析，但是使用多个Map要比一堆样板类更加清晰易懂”</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Object&gt; clusters;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Object&gt; contexts;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Object&gt; users;</span><br><span class="line">String currentContextName;</span><br><span class="line">Map&lt;String, Object&gt; currentContext;</span><br><span class="line">Map&lt;String, Object&gt; currentCluster;</span><br><span class="line">Map&lt;String, Object&gt; currentUser;</span><br><span class="line">String currentNamespace;</span><br><span class="line">Object preferences;</span><br><span class="line">ConfigPersister persister;</span><br></pre></td></tr></table></figure><p>standard 方法中，在执行完 loadKubeConfig 对象之后，会对传入的 persistConfig 标志位进行判断，如果为 true，则执行 setPersistConfig 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (persistConfig) &#123;</span><br><span class="line">  kc.setPersistConfig(<span class="keyword">new</span> FilePersister(kubeConfig));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 FilePersister 是 ConfigPersister 接口的一个具体实现，该接口仅有一个 save 方法，应当是将配置持久化的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigPersister</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ArrayList&lt;Object&gt; contexts,</span></span></span><br><span class="line"><span class="function"><span class="params">      ArrayList&lt;Object&gt; clusters,</span></span></span><br><span class="line"><span class="function"><span class="params">      ArrayList&lt;Object&gt; users,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object preferences,</span></span></span><br><span class="line"><span class="function"><span class="params">      String currentContext)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>standard 方法最后的执行过程是 kubeconfig 方法，方法的注释说明该方法用于从一个预配置好的 KubeConfig 对象中创建 builder，具体源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientBuilder <span class="title">kubeconfig</span><span class="params">(KubeConfig config)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ClientBuilder builder = <span class="keyword">new</span> ClientBuilder();</span><br><span class="line"></span><br><span class="line">  #拼装server字段</span><br><span class="line">  String server = config.getServer();</span><br><span class="line">  <span class="keyword">if</span> (!server.contains(<span class="string">"://"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.contains(<span class="string">":443"</span>)) &#123;</span><br><span class="line">      server = <span class="string">"https://"</span> + server;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      server = <span class="string">"http://"</span> + server;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #根据证书取出KubeConfig的数据或者文件</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] caBytes =</span><br><span class="line">      KubeConfig.getDataOrFile(</span><br><span class="line">          config.getCertificateAuthorityData(), config.getCertificateAuthorityFile());</span><br><span class="line">  #将kubeconfig对应的数据取出来填充进builder对象中</span><br><span class="line">  <span class="keyword">if</span> (caBytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">    builder.setCertificateAuthority(caBytes);</span><br><span class="line">  &#125;</span><br><span class="line">  builder.setVerifyingSsl(config.verifySSL());</span><br><span class="line"></span><br><span class="line">  builder.setBasePath(server);</span><br><span class="line">  builder.setAuthentication(<span class="keyword">new</span> KubeconfigAuthentication(config));</span><br><span class="line">  <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-Build-方法"><a href="#2-1-2-Build-方法" class="headerlink" title="2.1.2 Build 方法"></a>2.1.2 Build 方法</h3><p>经历以上过程，终于 standard 方法执行完毕并返回了一个包含各种认证鉴权相关信息的 builder 对象，接下来看看 build 方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ApiClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ApiClient client = <span class="keyword">new</span> ApiClient();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (basePath != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (basePath.endsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">      basePath = basePath.substring(<span class="number">0</span>, basePath.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    client.setBasePath(basePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  client.setVerifyingSsl(verifyingSsl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (authentication != <span class="keyword">null</span>) &#123;</span><br><span class="line">    authentication.provide(client);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//上述顺序很重要，因为一旦SSL信息更改，API客户端就会重新评估CA证书。这意味着如果上述流程发生在下面这个调用的后面，在尝试加载证书时，很可能会调用的InputStream已经耗尽。 因此，设置CA证书的顺序必须位于最后。</span></span><br><span class="line">  <span class="keyword">if</span> (caCertBytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">    client.setSslCaCert(<span class="keyword">new</span> ByteArrayInputStream(caCertBytes));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-剩余工作"><a href="#2-2-剩余工作" class="headerlink" title="2.2 剩余工作"></a>2.2 剩余工作</h2><p>经历以上步骤，终于完成了 ApiClient 复杂的创建过程。继续看看看看剩余工作，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#创建client对象</span><br><span class="line">ApiClient client = Config.defaultClient();</span><br><span class="line"></span><br><span class="line">#将client对象传入到Configuration类的类静态变量中</span><br><span class="line">Configuration.setDefaultApiClient(client);</span><br><span class="line"></span><br><span class="line">#CoreV1Api无参构造方法调用重载的带apiClient参数的构造方法，从Configuration类中取出client对象完成构造</span><br><span class="line">CoreV1Api api = <span class="keyword">new</span> CoreV1Api();</span><br><span class="line"></span><br><span class="line">#获得CoreV1Api对象后，填充参数执行对应的查询方法</span><br><span class="line">V1PodList list = api.listPodForAllNamespaces(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h1 id="0x03-总结流程"><a href="#0x03-总结流程" class="headerlink" title="0x03. 总结流程"></a>0x03. 总结流程</h1><p>经历以上的分析过程，大致完成了 list pods 的流程分析。结合 K8S 官方的概念流程文档可以验证之前学习的基于 API Server 的安全机制流程，可以看到 Authentication 和 Authorization 部分的数据填充过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从官方提供的代码入手，”列出所有 Pod”的示例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://study4.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://study4.fun/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kubernetes" scheme="https://study4.fun/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Go学习笔记——基础知识</title>
    <link href="https://study4.fun/2019-05-17-go-basic/"/>
    <id>https://study4.fun/2019-05-17-go-basic/</id>
    <published>2019-05-17T09:32:00.000Z</published>
    <updated>2022-05-21T07:33:17.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>静态语言，支持运行时动态类型；支持隐式类型推导；</li><li>接口基于<a href="https://zh.wikipedia.org/zh-hans/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">Duck 模型</a>；仅通过接口支持多态；不支持泛型但支持反射；</li><li>编译成可执行程序直接执行；支持自动垃圾回收；语言原生支持并发；跨平台；多应用于云计算基础设施软件、中间件、区块链等。</li></ul><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 文件名：hello.<span class="keyword">go</span></span><br><span class="line"># 包名，main为可执行程序的包名</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"># 引入外部包fmt（标准输入输出）</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"># 函数声明，main代表程序入口函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hello, world.\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：</p><ul><li>Go 的源程序默认使用 UTF-8 编码</li><li>语句结尾的分号可以省略</li><li>“{”必须在函数头所在行尾部，不能单独起一行</li><li>main 函数所在的包名必须是 main。</li></ul><p>编译运行</p><ul><li>编译 go build hello.go</li><li>运行 ./hello</li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>（仅记录与 Java 不同的）</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>常量声明 const、变量定义 var、函数定义 func、延迟执行 defer、 结构类型定义 struct、通道类型 chan</p><h3 id="数据类型标识"><a href="#数据类型标识" class="headerlink" title="数据类型标识"></a>数据类型标识</h3><table><thead><tr><th>类型</th><th>标识</th></tr></thead><tbody><tr><td>整型</td><td>byte int int8-int64 uint uint8-uint64 uintptr （byte 就是 uint8）</td></tr><tr><td>浮点数</td><td>float32 float64 （自动类型推断为 float64）</td></tr><tr><td>复数</td><td>complex64 complex128 （由两个 float 构成，对应实部和虚部）</td></tr><tr><td>字符</td><td>rune</td></tr><tr><td>接口</td><td>error</td></tr><tr><td>连续枚举类型</td><td>iota</td></tr><tr><td>匿名变量</td><td>_</td></tr></tbody></table><p>iota 用法: iota 用于常量声明中，初始值为 0，逐行增加</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="literal">iota</span>          <span class="comment">//iota=0,a=0</span></span><br><span class="line">b                 <span class="comment">//iota=1,b=1</span></span><br><span class="line">c = <span class="number">3</span>             <span class="comment">//iota=2,未使用，c=3</span></span><br><span class="line">d = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">//iota=3,d=8</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注意：Go 语言里自增和自减是语句而不是表达式[1]</p><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式声明，value可以是表达式，不指定则初始化为类型零值，声明后立即分配空间</span></span><br><span class="line"><span class="keyword">var</span> varName dataType [ = value]</span><br><span class="line"><span class="comment">//短类型声明，只能出现在函数内，自动进行数据类型推断</span></span><br><span class="line">varName := value</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持多个类型变量同时声明并赋值</span></span><br><span class="line">a, b := <span class="number">1</span>, <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><h3 id="字符串和切片"><a href="#字符串和切片" class="headerlink" title="字符串和切片"></a>字符串和切片</h3><ul><li>字符串可以通过类似数组索引的方式访问，但是不能修改</li><li>字符串转换为切片[]byte()在数据量大的时候要慎用，因为转换的时候需要复制内容</li><li>字符串的底层实现是一个指向字节数组的指针和字节数组长度</li><li>基于字符串创建的切片指向原字符串指向的字符数组，不可修改</li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul><li>结构体指针访问结构体字段仍然使用”.”操作符，没有“-&gt;”</li><li>不支持指针运算（GO 支持垃圾回收，语言层面禁止指针运算）</li><li>允许返回局部变量地址</li></ul><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片（可变数组）维护三个元素——指向底层数组的指正、切片元素数量、底层数组容量</p><p>创建方式：数组索引、make</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Go 内置的 map 不是并发安全的，需要时用 sync 包内的 map 保证并发安全</p><p>map 键值对的修改不能通过 map 引用直接修改键值，需要 KV 整体赋值</p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><h3 id="If-else"><a href="#If-else" class="headerlink" title="If-else"></a>If-else</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> initialization; condition &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><ul><li>条件表达式支持任意支持相等比较运算的类型变量</li><li>switch 后面可以带上初始化语句</li><li>case 后可以使用多个值比较，使用逗号分隔</li><li>配合使用可以进行类型查询</li></ul><h3 id="Goto"><a href="#Goto" class="headerlink" title="Goto"></a>Goto</h3><ul><li>goto 需要配合标签使用</li><li>goto 只能在函数内跳转，但是不能跳过内部变量声明语句，只能跳过同级作用域或上层作用域</li></ul><h1 id="Q："><a href="#Q：" class="headerlink" title="Q："></a>Q：</h1><p>【1】这是否意味着自增或自减是原子操作？<br>答：不是。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;静态语言，支持运行时动态类型；支持隐式类型推导；&lt;/li&gt;
&lt;li&gt;接口基于&lt;a href=&quot;https://zh.wikipe
      
    
    </summary>
    
    
      <category term="备忘录" scheme="https://study4.fun/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="Golang" scheme="https://study4.fun/tags/Golang/"/>
    
      <category term="学习笔记" scheme="https://study4.fun/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes学习笔记——基于API Server的安全机制浅析</title>
    <link href="https://study4.fun/2019-04-25-k8s-api-server-security/"/>
    <id>https://study4.fun/2019-04-25-k8s-api-server-security/</id>
    <published>2019-04-25T02:50:00.000Z</published>
    <updated>2022-05-21T07:33:17.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集群安全机制的目标"><a href="#集群安全机制的目标" class="headerlink" title="集群安全机制的目标"></a>集群安全机制的目标</h1><ul><li>隔离性，限制容器给集群带来的副作用</li><li>最小权限原则</li><li>组件的边界划分需要明确</li><li>角色划分和权限分配</li></ul><h1 id="关于-API-Server"><a href="#关于-API-Server" class="headerlink" title="关于 API Server"></a>关于 API Server</h1><p>API Server 作为集群控制请求的实际入口，通常暴露了两个端口——本地端口(Localhost Por)和安全端口(Secure Port)。</p><table><thead><tr><th></th><th>本地端口</th><th>安全端口</th></tr></thead><tbody><tr><td>使用场景</td><td>测试和启动时使用，Master 节点中不同组件通信</td><td>任意场景</td></tr><tr><td>安全协议</td><td>无</td><td>TLS</td></tr><tr><td>端口</td><td>默认 8080，</td><td></td></tr></tbody></table><p><code>insecure-port</code><br>修改 | 默认 6443，<br><code>secure-port</code><br>修改 |<br>| IP | 默认 localhost,<br><code>insecure-bind-address</code><br>修改 | 默认为第一个非 localhost 网卡地址，<br><code>bind-address</code><br>修改 |<br>| 处理流程 | 无需认证和授权 | 需要认证和授权 |<br>| 准入控制 | 是 | 是 |<br>| 访问控制 | 需要拥有主机访问权限 | 需要认证和授权模块正常运行 |</p><p>注：TLS 中，证书和私钥相关参数为<code>tls-cert-file</code> 和 <code>tls-private-key-file</code>。<br>访问 API Server 的方式有 kubectl，客户端的库和 Rest 请求。通常来说，想在外部访问 API Server 需要通过安全端口访问。通过安全端口访问需要经过三重校验，即 Authentication（身份认证），Authorization（授权）和 Admission Control（准入控制）。<br><img src="https://cdn.nlark.com/yuque/0/2020/svg/379285/1589796346707-11dd1d0c-1251-4060-974b-976b3a229552.svg#height=150&id=E7DbX&originHeight=150&originWidth=267&originalType=binary&size=0&status=done&style=none&width=267" alt=""></p><h1 id="Authentication（身份认证）"><a href="#Authentication（身份认证）" class="headerlink" title="Authentication（身份认证）"></a>Authentication（身份认证）</h1><blockquote><p><strong>Authentication</strong> is the act of confirming the truth of an attribute of a single piece of data claimed true by an entity.<br>From: <a href="https://en.wikipedia.org/wiki/Authentication" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Authentication</a><br>通俗的来说，身份认证解决的是“让系统/服务端知道你是谁”的问题，即对用户身份的确认。值得注意的是，Wikipedia 中还特别标注“ <em>Not to be confused with authorization.</em> ”<br>对于身份的认证，现实生活中可能是查验证件，也可能是对暗号。</p></blockquote><p>对应的，在 Kubernetes 中，也有对应的几种客户端身份认证方式：</p><ul><li>证书认证：基于 CA 根证书签名的双向数字证书认证方式；</li><li>Token 认证：通过 Token 来认证；</li><li>用户密码：通过用户密码的方式认证；</li></ul><p>可以同时指定多个身份认证模块，在流程中将会以顺序执行的方式进行认证过程，直到其中一个认证模块认证成功。如果请求认证失败，则会返回 401 状态码。（PS：这里引入了一个 401 状态码的历史遗留问题——401 的语义其实应该是 Unauthenticated）</p><p>一旦认证成功，用户就会被分配一个特定的 username。在随后的访问控制流程中，这个 username 将会一直使用。尽管如此，这个 username 却也不会对应存在一个真实的<strong>用户对象</strong>，该信息也不会被存储。</p><p>（我的理解：这个所谓的 username 的存在仅仅是为了在整个访问控制流程中能够进行上下文信息的传递，完成一个链式的验证。和传统意义上的用户相比，K8S 的访问控制基于单次的请求，在请求的过程中抽象来决定行为的合法性和有效性。）</p><h1 id="Authorization（授权）"><a href="#Authorization（授权）" class="headerlink" title="Authorization（授权）"></a>Authorization（授权）</h1><blockquote><p><strong>Authorization</strong> is the function of specifying access rights/privileges to resources, which is related to information security and computer security in general and to access control in particular.<br>From: <a href="https://en.wikipedia.org/wiki/Authorization" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Authorization</a><br>与身份认证不同的是，授权关注的是对资源的访问控制，通俗的说就是“系统要知道你这个身份能够做什么”。</p></blockquote><p>当请求通过了身份认证之后，请求才会进入授权流程。请求的内容包含三个部分：用户名（username of the requester），动作（ requested action），动作影响的对象（the object affected by the action）。在已有的多种授权策略中，只要有一个能够声明此用户有执行对应动作的权限，则请求就被授权成功。若所有授权策略全部失败，则返回 403 状态码。<br>授权模块的种类：</p><ul><li>ABAC</li><li>RBAC</li><li>Node</li><li>Webhook</li></ul><h1 id="Admission-Control（准入控制）"><a href="#Admission-Control（准入控制）" class="headerlink" title="Admission Control（准入控制）"></a>Admission Control（准入控制）</h1><p>通过认证和授权流程之后，请求的调用还需要通过准入控制链的检查。与上述模块不同，准入控制能够修改请求参数完成一些任务。<br>当多个准入控制模块配置完毕后，请求的调用会依次按顺序进行检查。一旦任意一个准入控制模块检查不通过，则请求立即被拒绝。而请求完成了所有检查后，会采用相应 API 对象的验证流程对请求进行验证，然后写入对象库。</p><blockquote><p>Once a request passes all admission controllers, it is validated using the validation routines for the corresponding API object, and then written to the object store (shown as step <strong>4</strong>).</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从整体来看，Kubernetes 对于 API Server 的请求主要分为两大部分：内部和外部。<br>内部是指在 master 节点使用 kubectl 命令进行操作，这时，因为是在节点内部操作，因此并不会使用安全端口，直接采用 localhost 这个 ip 上的非安全端口进行访问。<br>而对于 API Server 的外部请求调用（包括 Pod 和 Rest 请求），则需要使用安全端口进行访问。通过安全端口的请求，需要进行严格的三层校验才能调用成功。这就通过确保只执行权限内允许的操作保证了集群操作的安全性。<br>关于每个部分的详细介绍，会单独抽成三部分继续分解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集群安全机制的目标&quot;&gt;&lt;a href=&quot;#集群安全机制的目标&quot; class=&quot;headerlink&quot; title=&quot;集群安全机制的目标&quot;&gt;&lt;/a&gt;集群安全机制的目标&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;隔离性，限制容器给集群带来的副作用&lt;/li&gt;
&lt;li&gt;最小权限原则&lt;/l
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://study4.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Kubernetes" scheme="https://study4.fun/tags/Kubernetes/"/>
    
      <category term="API Server" scheme="https://study4.fun/tags/API-Server/"/>
    
  </entry>
  
  <entry>
    <title>校园网下OpenWrt配置DNS</title>
    <link href="https://study4.fun/2018-09-09-config-dns/"/>
    <id>https://study4.fun/2018-09-09-config-dns/</id>
    <published>2018-09-09T05:55:00.000Z</published>
    <updated>2022-05-21T07:33:17.268Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章的末尾写到，初次配置 OP 系统时候在校内网实现了 IPV6 穿透，但是 DNS 出现了问题。查阅资料后发现与 OP 的反域名劫持保护机制有关系，下面详述一下。</p><h1 id="0x02-OP-的反域名劫持保护"><a href="#0x02-OP-的反域名劫持保护" class="headerlink" title="0x02 OP 的反域名劫持保护"></a>0x02 OP 的反域名劫持保护</h1><p>OP 的反域名劫持保护在默认情况是开开启的，具体设置在<code>/etc/config/dhcp</code>下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config dnsmasq</span><br><span class="line">    option rebind_protection &#39;1&#39;</span><br></pre></td></tr></table></figure><p>在反域名劫持保护未关闭的情况下，由于上级 dns 返回的地址是个私有局域网地址，所以被看作是一次域名劫持，从而丢弃了解析的结果。</p><p>直接的方法就是将上面的字段值改为<code>0</code>，关闭即可。<br>在 GUI 配置界面等同于将<br><code>Network-&gt;DHCP DNS-Server Settings-&gt;General Settings-&gt;Rebind protection</code>的勾取消掉。</p><p>再仔细查看文档发现也可以通过白名单的方式放行想要解析的内网域名，更为安全,此时 Rebind protection 也是处于开启状态，上面的关闭操作不需要进行。而具体修改的操作示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config dnsmasq</span><br><span class="line">    list rebind_domain &#39;bupt.edu.cn&#39;</span><br><span class="line">    list rebind_domain &#39;byr.cn&#39;</span><br></pre></td></tr></table></figure><p>表示在反域名劫持保护情况下，将<code>bupt.edu.cn</code>,<code>byr.cn</code>域名加入白名单，允许返回内网地址。<br>在 GUI 配置界面等同于在<br><code>Network-DHCP DNS-Server Settings-General Settings-Domain whitelist</code>添加想要解析的内网域名。</p><h1 id="0x03-自定义-DNS-规则"><a href="#0x03-自定义-DNS-规则" class="headerlink" title="0x03 自定义 DNS 规则"></a>0x03 自定义 DNS 规则</h1><p>在学校 DNS 偶尔抽风或者速度慢的情况下，产生了自定义 DNS 的想法。由于教务系统等系统的访问需要，在各个客户端修改 hosts 略显麻烦，并且 DNSmasq 亦可以实现广告屏蔽，因此采用 DNSmasq 来实现不同的 DNS 解析。<br>预期需求为<code>bupt.edu.cn</code>, <code>byr.cn</code>域名使用校内 DNS 解析，其他地址使用公共 DNS 解析（以 114 为例）。</p><h2 id="修改-Wan-口-DNS"><a href="#修改-Wan-口-DNS" class="headerlink" title="修改 Wan 口 DNS"></a>修改 Wan 口 DNS</h2><p>Wan 口 DNS 主要控制路由器访问网络使用的 DNS 服务器。例如，路由器安装软件需要访问网络，那么所使用的 DNS 服务器就是这个。</p><p>在<code>/etc/config/network</code>文件中的 wan 接口添加两行 peerdns 以及 dns 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config interface &#39;wan&#39;</span><br><span class="line">    ......</span><br><span class="line">    option peerdns &#39;0&#39;</span><br><span class="line">    option dns &#39;114.114.114.114&#39;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>重启 network 服务后生效。<br>在 GUI 配置界面等同于在<code>Network-Interface-Wan-Edit-Common Configuration-Advanced Settings</code>中取消<code>Use DNS servers advertised by peer</code>的勾选，并在<code>Use custom DNS servers</code>添加默认的 DNS 服务器。</p><h2 id="修改-Lan-口-DNS（可跳过）"><a href="#修改-Lan-口-DNS（可跳过）" class="headerlink" title="修改 Lan 口 DNS（可跳过）"></a>修改 Lan 口 DNS（可跳过）</h2><p>LAN 口 DNS 主要控制连接到路由器的设备使用的 DNS。例如，连到路由的电脑上网时使用的 DNS 服务器就在这里设置。</p><p>一般情况下，Lan 和 Wan 口 DNS 保持一致即可。如若有需要，修改<code>/etc/config/dhcp</code>文件中 dnsmasq 的 resolvfile 指向即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config dnsmasq</span><br><span class="line">    ....</span><br><span class="line">    option resolvfile &#39;&#x2F;etc&#x2F;resolv.dnsmasq.conf&#39;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>同时需要在<code>/etc/resolv.dnsmasq.conf</code>下新建对应的配置文件。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 2001:4860:4860::8888</span><br></pre></td></tr></table></figure><h2 id="修改-Dns-自定义的内网解析规则"><a href="#修改-Dns-自定义的内网解析规则" class="headerlink" title="修改 Dns 自定义的内网解析规则"></a>修改 Dns 自定义的内网解析规则</h2><p>接下来就是配置校内域名使用的 DNS 解析地址。修改<code>/etc/config/dhcp</code>文件中 dnsmasq。<br>首先是删除下面两行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config dnsmasq</span><br><span class="line">    ....</span><br><span class="line">    option filterwin2k &#39;0&#39;</span><br><span class="line">    option nonegcache &#39;0&#39;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>其次添加 list server 字段，对<code>bupt.edu.cn</code>, <code>byr.cn</code>相关域名使用校内 DNS 解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config dnsmasq</span><br><span class="line">    list server &#39;&#x2F;bupt.edu.cn&#x2F;10.3.9.5&#39;</span><br><span class="line">    list server &#39;&#x2F;byr.cn&#x2F;10.3.9.5&#39;</span><br></pre></td></tr></table></figure><p>在 GUI 配置界面等同于在<br><code>Network-DHCP and DNS-Server Settings-General Settings-DNS forwardings</code>添加对应域名的 DNS 解析服务器地址。</p><h1 id="0x04-后话"><a href="#0x04-后话" class="headerlink" title="0x04 后话"></a>0x04 后话</h1><p>DNSmasq 的用法远不止于此，可用来内网域名 IP 映射代替 hosts，自定义域名解析规则屏蔽广告等，有时间会再研究。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇文章的末尾写到，初次配置 OP 系统时候在校内网实现了 IPV6 穿透，但是 DNS 出现了问题。查阅资料后发现与 OP 的反域名劫持保护机制有关系，下面详述一下。&lt;/p&gt;
&lt;h1 id=&quot;0x02-OP-的反域名劫持保护&quot;&gt;&lt;a href=&quot;#0x02-OP-的反
      
    
    </summary>
    
    
      <category term="杂项" scheme="https://study4.fun/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="网络配置" scheme="https://study4.fun/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
      <category term="DNS" scheme="https://study4.fun/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes学习笔记——Pod调度</title>
    <link href="https://study4.fun/2018-09-09-k8s-pod-scheduling/"/>
    <id>https://study4.fun/2018-09-09-k8s-pod-scheduling/</id>
    <published>2018-09-09T05:55:00.000Z</published>
    <updated>2022-05-21T07:33:17.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-Deployment-RC-全自动调度"><a href="#0x01-Deployment-RC-全自动调度" class="headerlink" title="0x01. Deployment/RC 全自动调度"></a>0x01. Deployment/RC 全自动调度</h1><p><strong>效果：</strong>在集群内始终维持用户指定的副本数量</p><p><strong>使用：</strong>spec.replicas</p><p><strong>原理：</strong>系统自动调度算法。由 Master 的 Scheduler 经过一系列算法计算得出，用户无法干预调度过程和结果。</p><h1 id="0x02-NodeSelector"><a href="#0x02-NodeSelector" class="headerlink" title="0x02. NodeSelector"></a>0x02. NodeSelector</h1><p><strong>效果：</strong>通过 Node 的标签和 Pod 的 nodeSelector 属性进行匹配，将 Pod 调度到指定的 Node 上</p><p><strong>使用：</strong></p><ol><li>为目标 Node 打标签</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 Pod 定义中加上 nodeSelector 的设置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pod.yaml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="string">&lt;label-key&gt;:</span> <span class="string">&lt;your-selected-label-name&gt;</span></span><br></pre></td></tr></table></figure><p><strong>补充：</strong></p><ul><li>如果多个 Node 定义了相同的标签，则会根据调度算法从这组 Node 中挑选一个可用的 Node 进行调度</li><li>若 Pod 指定的 nodeSelector 条件集群中不存在符合的节点，则该 Pod 无法被成功调度，即使集群中还有可用的 Node</li></ul><h1 id="0x03-亲和性调度"><a href="#0x03-亲和性调度" class="headerlink" title="0x03. 亲和性调度"></a>0x03. 亲和性调度</h1><p>篇幅原因，另外一篇单独记录</p><h1 id="0x04-污点-Taints-和容忍-Tolerations"><a href="#0x04-污点-Taints-和容忍-Tolerations" class="headerlink" title="0x04. 污点(Taints)和容忍(Tolerations)"></a>0x04. 污点(Taints)和容忍(Tolerations)</h1><p><strong>效果：</strong>Pod 无法在标记了 Taint 属性的节点上运行, 同时，设置了 Tolerations 的 Pod 可以运行在标注了 Taint 的 Node 上</p><p><strong>使用：</strong></p><ol><li>为 Node 设置 Taint 信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes node1 key1=value1:NoSchedule</span><br></pre></td></tr></table></figure><ol start="2"><li>在 Pod 的配置文件中配置 tolerations 属性</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"key"</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">"value"</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">"NoSchdule"</span></span><br></pre></td></tr></table></figure><p><strong>补充：</strong></p><ul><li>Taint 和 Toleration 声明需要保持对应一致，且 operator 需要为 Exists 或者 Equal（Equal 需要指定相等 value）；</li><li>空 key 配合 Exists 能够匹配所有键值，空 effect 匹配所有 effect；</li><li>effect 取值也可以设置为 Prefer，例如 PreferNoSchedule，视为软限制；</li><li>同个 Node 可以设置多个 Taint，对应的，Pod 也可以设置多个 Toleration。</li></ul><h1 id="0x05-DaemonSet"><a href="#0x05-DaemonSet" class="headerlink" title="0x05. DaemonSet"></a>0x05. DaemonSet</h1><p><strong>效果：</strong>在每个 Node 上调度运行同一个（种）Pod，例如日志采集、性能监控、存储的 Daemon 进程</p><p><strong>使用：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br></pre></td></tr></table></figure><p><strong>补充：</strong></p><p>除了使用系统内置算法在每台 Node 上调度外，也可以在 Pod 定义中使用 NodeSelector 或者 NodeAffinity 来指定满足料件的 Node 范围进行调度</p><h1 id="0x06-批处理调度"><a href="#0x06-批处理调度" class="headerlink" title="0x06. 批处理调度"></a>0x06. 批处理调度</h1><p><strong>效果：</strong>并行/串行启动多个计算进程去处理一批工作项（Work Item，下称 WI），处理完成后，批处理任务结束</p><p><strong>任务模式分类：</strong></p><ul><li><strong>Job Template Expansion 模式</strong>：Job 和 WI 一对一对应，适用于 WI 数量少，但是单 WI 处理数据量大的场景；</li><li><strong>Queue with Pod Per Work Item 模式</strong>：使用一个任务队列存放 WI，Job 作为 Consumer 去完成 WI（对应的，Job 会启动多个 Pod，每个 Pod 对应一个 WI），可用 MQ 实现；</li><li><strong>Queue with Variable Pod Count 模式</strong>：与 2 模式类似，但是 Job 启动的 Pod 数量是可变的，可用 Redis 或数据库实现；</li><li><strong>Single Job with Static Work Assignment 模式</strong>：一个 Job 产生多个 Pod，但是采用程序静态方式分配任务（Kubernetes 不支持，书中所写）。</li></ul><p><strong>Job 分类：</strong></p><ul><li><strong>Non-parallel Jobs</strong>：一个 Job 启动一个 Pod，Pod 正常结束则 Job 结束。</li><li><strong>Parallel Jobs with a fixed completion count</strong>：Job 会启动多个 Pod（数目为 spec.completions），正常结束的 Pod 达到这个数目后 Job 结束。spec.parallelism 可以用来控制并行度。</li><li><strong>Parallel Jobs with a work queue</strong>：WI 在 Queue 中存放，无法设置并行度参数。每个 Pod 都能够独立判断是否还有任务需要处理，同时，一个 Pod 成功结束则其他 Pod 必定处于即将结束、退出的状态，且 Job 不会再启动新的 Po）。所有 Pod 结束，且至少一个 Pod 成功结束则 Job 算成功结束。</li></ul><p>（个人理解：上述的规则说明其实是在说所有 Pod 表现为同一整体，Pod 启动失败会重启是一种容错机制。然而从整个过程的跨度来看，无需关心失败启动的数目，只要不是所有 Pod 全部失败结束，只需存在一个成功结束的 Pod 即表明 Job 流程内的其他划分任务都正常完成，整体任务也已成功完成。）</p><h1 id="0x07-定时任务"><a href="#0x07-定时任务" class="headerlink" title="0x07. 定时任务"></a>0x07. 定时任务</h1><p><strong>效果：</strong>定期触发任务执行</p><p><strong>使用：</strong></p><ol><li>在 API Server 启动进程上添加配置参数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--runtime-config=batch/v2alpha1=true</span><br></pre></td></tr></table></figure><ol start="2"><li>编写 Cron Job 配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cron.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v2alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">"*/1 * * * *"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>schedule 格式如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Min Hour DayOfMonth Month DayOfWeek</span><br></pre></td></tr></table></figure><ol start="2"><li>*表示任意值，即每个时间单元节点都会触发</li></ol><p>/表示开始触发的时间，例如 5/20，表明第一次触发在第 5 个时间单位，此后每隔 20 个时间单位触发</p><h1 id="0x08-自定义调度器"><a href="#0x08-自定义调度器" class="headerlink" title="0x08. 自定义调度器"></a>0x08. 自定义调度器</h1><p>在 Pod 中提供自定义的调度器名称，则默认调度器就会失效，转而使用指定的调度器完成对应 Pod 的调度，自定义的调度器需要通过 kube-proxy 来运行，如果自定义调度器始终未启动，则 Pod 将会卡 Pending 状态。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedulerName:</span> <span class="string">my-scheduler</span></span><br></pre></td></tr></table></figure><h1 id="0x09-补充"><a href="#0x09-补充" class="headerlink" title="0x09. 补充"></a>0x09. 补充</h1><ul><li>Admission controller 需要仔细研究</li><li>TaintBasedEviction 和 Eureka 中的驱逐机制（包括 SELF PRESERVATION)是否在设计层面上有一定的共通点</li><li>自定义调度器实现有时间需要手动验证一次</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01-Deployment-RC-全自动调度&quot;&gt;&lt;a href=&quot;#0x01-Deployment-RC-全自动调度&quot; class=&quot;headerlink&quot; title=&quot;0x01. Deployment/RC 全自动调度&quot;&gt;&lt;/a&gt;0x01. Deploym
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://study4.fun/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://study4.fun/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Kubernetes" scheme="https://study4.fun/tags/Kubernetes/"/>
    
      <category term="Pod" scheme="https://study4.fun/tags/Pod/"/>
    
  </entry>
  
  <entry>
    <title>双栈网络配置路由器的ipv6穿透</title>
    <link href="https://study4.fun/2016-03-20-config-ipv6/"/>
    <id>https://study4.fun/2016-03-20-config-ipv6/</id>
    <published>2016-03-20T14:47:00.000Z</published>
    <updated>2022-05-21T07:33:17.304Z</updated>
    
    <content type="html"><![CDATA[<p>本教程测试过程基于 Newifi Y2 路由器，系统为 PandoraBox，理论上 OpenWrt 原生同样适用。</p><h1 id="1-修改路由器的软件源"><a href="#1-修改路由器的软件源" class="headerlink" title="1.修改路由器的软件源"></a>1.修改路由器的软件源</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dest root &#x2F;</span><br><span class="line">dest ram &#x2F;tmp</span><br><span class="line">lists_dir ext &#x2F;var&#x2F;opkg-lists</span><br><span class="line">option overlay_root &#x2F;overlay</span><br><span class="line">src&#x2F;gz 14.09_base http:&#x2F;&#x2F;downloads.openwrt.org.cn&#x2F;PandoraBox&#x2F;ralink&#x2F;packages&#x2F;base</span><br><span class="line">src&#x2F;gz 14.09_telephony http:&#x2F;&#x2F;downloads.openwrt.org&#x2F;chaos_calmer&#x2F;15.05&#x2F;ramips&#x2F;mt7620&#x2F;packages&#x2F;telephony</span><br><span class="line">src&#x2F;gz 14.09_packages http:&#x2F;&#x2F;downloads.openwrt.org&#x2F;chaos_calmer&#x2F;15.05&#x2F;ramips&#x2F;mt7620&#x2F;packages&#x2F;packages</span><br><span class="line">src&#x2F;gz 14.09_routing http:&#x2F;&#x2F;downloads.openwrt.org&#x2F;chaos_calmer&#x2F;15.05&#x2F;ramips&#x2F;mt7620&#x2F;packages&#x2F;routing</span><br><span class="line">src&#x2F;gz 14.09_management http:&#x2F;&#x2F;downloads.openwrt.org&#x2F;chaos_calmer&#x2F;15.05&#x2F;ramips&#x2F;mt7620&#x2F;packages&#x2F;management</span><br><span class="line">arch ralink 1</span><br><span class="line">arch all 2</span><br><span class="line">arch ramips_24kec 3</span><br></pre></td></tr></table></figure><p>注:软件源由于硬件配置不同的会有所区别，Newifi 是 MT7620 方案，其他芯片方案的请移步以下两个网址自行匹配：</p><blockquote><p>OpenWrt 中文网址  <a href="http://downloads.openwrt.org.cn/" target="_blank" rel="noopener">http://downloads.openwrt.org.cn/</a><br>OpenWrt download area <a href="https://downloads.openwrt.org/" target="_blank" rel="noopener">https://downloads.openwrt.org/</a></p></blockquote><h1 id="2-配置-Odhcpd"><a href="#2-配置-Odhcpd" class="headerlink" title="2.配置 Odhcpd"></a>2.配置 Odhcpd</h1><ul><li>软件包中更新并安装最新版本的 odhcpd</li><li>修改 dhcp 文件（文件路径：/etc/config/dhcp，不熟悉 ssh 的可以使用 winscp 修改)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">config dnsmasq</span><br><span class="line">option domainneeded &#39;1&#39;</span><br><span class="line">option boguspriv &#39;1&#39;</span><br><span class="line">option filterwin2k &#39;0&#39;</span><br><span class="line">option localise_queries &#39;1&#39;</span><br><span class="line">option rebind_protection &#39;1&#39;</span><br><span class="line">option rebind_localhost &#39;1&#39;</span><br><span class="line">option local &#39;&#x2F;lan&#x2F;&#39;</span><br><span class="line">option domain &#39;lan&#39;</span><br><span class="line">option expandhosts &#39;1&#39;</span><br><span class="line">option nonegcache &#39;0&#39;</span><br><span class="line">option authoritative &#39;1&#39;</span><br><span class="line">option readethers &#39;1&#39;</span><br><span class="line">option leasefile &#39;&#x2F;tmp&#x2F;dhcp.leases&#39;</span><br><span class="line">option resolvfile &#39;&#x2F;tmp&#x2F;resolv.conf.auto&#39;</span><br><span class="line">option localservice &#39;1&#39;</span><br><span class="line"></span><br><span class="line">config dhcp &#39;lan&#39;</span><br><span class="line">option interface &#39;lan&#39;</span><br><span class="line">option start &#39;100&#39;</span><br><span class="line">option limit &#39;150&#39;</span><br><span class="line">option leasetime &#39;12h&#39;</span><br><span class="line">option dhcpv6 &#39;hybrid&#39;</span><br><span class="line">option ra &#39;hybrid&#39;</span><br><span class="line">option ndp &#39;hybrid&#39;</span><br><span class="line">option ra_management &#39;1&#39;</span><br><span class="line"></span><br><span class="line">config dhcp &#39;wan&#39;</span><br><span class="line">option interface &#39;wan&#39;</span><br><span class="line">option ignore &#39;1&#39;</span><br><span class="line"></span><br><span class="line">config odhcpd &#39;odhcpd&#39;</span><br><span class="line">option maindhcp &#39;0&#39;</span><br><span class="line">option leasefile &#39;&#x2F;tmp&#x2F;hosts&#x2F;odhcpd&#39;</span><br><span class="line">option leasetrigger &#39;&#x2F;usr&#x2F;sbin&#x2F;odhcpd-update&#39;</span><br><span class="line"></span><br><span class="line">config dhcp &#39;wan6&#39;</span><br><span class="line">option interface &#39;wan&#39;</span><br><span class="line">option dhcpv6 &#39;hybrid&#39;</span><br><span class="line">option ra &#39;hybrid&#39;</span><br><span class="line">option ndp &#39;hybrid&#39;</span><br><span class="line">option master &#39;1&#39;</span><br></pre></td></tr></table></figure><p>修改后保存并重启路由器即可。</p><h1 id="3-后话"><a href="#3-后话" class="headerlink" title="3.后话"></a>3.后话</h1><p><del>配置后好像 dns 出了一些问题，在访问其他校内以.byr.cn 或.bupt.edu.cn 为后缀的网址显示 dns 错误，如果有大牛解决了这个 DNS 问题，可以分享一下思路。</del></p><p>2018.9.9 更新：后话所述问题已经解决</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本教程测试过程基于 Newifi Y2 路由器，系统为 PandoraBox，理论上 OpenWrt 原生同样适用。&lt;/p&gt;
&lt;h1 id=&quot;1-修改路由器的软件源&quot;&gt;&lt;a href=&quot;#1-修改路由器的软件源&quot; class=&quot;headerlink&quot; title=&quot;1.修改
      
    
    </summary>
    
    
      <category term="杂项" scheme="https://study4.fun/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="网络配置" scheme="https://study4.fun/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
      <category term="IPV6" scheme="https://study4.fun/tags/IPV6/"/>
    
  </entry>
  
</feed>
